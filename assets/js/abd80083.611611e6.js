"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[13793],{28453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>a});var n=r(96540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}},79872:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"nodejs-typescript/worker-threads","title":"Introduction to Worker Threads with TypeScript","description":"\u672c\u6587\u8f6c\u8f7d\u81ea Node.js TypeScript","source":"@site/src/docs/articles/nodejs-typescript/12-worker-threads.md","sourceDirName":"nodejs-typescript","slug":"/nodejs-typescript/worker-threads","permalink":"/docs/articles/nodejs-typescript/worker-threads","draft":false,"unlisted":false,"editUrl":"https://github.com/alanwei43/blog/tree/master/src/docs/articles/nodejs-typescript/12-worker-threads.md","tags":[{"inline":true,"label":"node.js","permalink":"/docs/articles/tags/node-js"},{"inline":true,"label":"typescript","permalink":"/docs/articles/tags/typescript"}],"version":"current","lastUpdatedAt":1662779172000,"sidebarPosition":12,"frontMatter":{"title":"Introduction to Worker Threads with TypeScript","tags":["node.js","typescript"]},"sidebar":"tutorialSidebar","previous":{"title":"VS Code \u5bb9\u5668\u5f00\u53d1\u7b80\u4ecb","permalink":"/docs/articles/vsc-container/samples"},"next":{"title":"Sending data between Worker Threads","permalink":"/docs/articles/nodejs-typescript/sending-data-worker-threads"}}');var o=r(74848),s=r(28453);const i={title:"Introduction to Worker Threads with TypeScript",tags:["node.js","typescript"]},a=void 0,c={},d=[{value:"Introduction to TypeScript Worker Threads",id:"introduction-to-typescript-worker-threads",level:2},{value:"TypeScript support in Worker Threads",id:"typescript-support-in-worker-threads",level:3},{value:"Communicating between threads",id:"communicating-between-threads",level:3},{value:"Communicating with the parent thread",id:"communicating-with-the-parent-thread",level:2},{value:"Summary",id:"summary",level:2}];function h(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["\u672c\u6587\u8f6c\u8f7d\u81ea ",(0,o.jsx)(t.a,{href:"https://wanago.io/2019/05/06/node-js-typescript-12-worker-threads/",children:"Node.js TypeScript"})]})}),"\n",(0,o.jsx)(t.p,{children:"The Node.js and JavaScript are often perceived as a single-threaded but in this series, we prove that it is not entirely true. Node.js creates threads when performing Input/Output operations. Not only that, but we can also create additional processes. While the above does not count yet as multithreading, in this article we begin to cover the basics of TypeScript Worker Threads and explore how they work and compare them to other ways of running JavaScript in parallel that we\u2019ve used so far."}),"\n",(0,o.jsx)(t.h2,{id:"introduction-to-typescript-worker-threads",children:"Introduction to TypeScript Worker Threads"}),"\n",(0,o.jsxs)(t.p,{children:["First, let\u2019s look into why would we want another way of running multiple pieces of code at once. In the 10th part of this series, we cover the ",(0,o.jsx)(t.strong,{children:"child process"})," module. It allows us to create additional Node.js processes with all its advantages and disadvantages. Since child processes don\u2019t share any memory, every one of them needs to manage their own environment to run Node.js code. Not only it uses quite a bit of memory: it also takes some time to get it to run. Threads, compared to multiple processes, are lighter when it comes to resources."]}),"\n",(0,o.jsx)(t.h3,{id:"typescript-support-in-worker-threads",children:"TypeScript support in Worker Threads"}),"\n",(0,o.jsxs)(t.p,{children:["Even though the Worker Threads module is relatively new, it has solid TypeScript support when it comes to types. When we look ",(0,o.jsx)(t.a,{href:"https://github.com/DefinitelyTyped/DefinitelyTyped/blob/df175aa50bc88447a9e1fb15d9a6b9c89c50246b/types/node/worker_threads.d.ts",children:"into the DefinitelyTyped repository"})," , all the use cases that we need in this article are covered. Moreover, ",(0,o.jsx)(t.a,{href:"https://github.com/DefinitelyTyped/DefinitelyTyped/commits/df175aa50bc88447a9e1fb15d9a6b9c89c50246b/types/node/worker_threads.d.ts",children:"in the history of the typings"}),", you can see that they receive updates along with new versions of Node.js. It is very important because the Worker Threads module is still in the experimental stage. It means that it is still in active development and therefore its API can still change. The Node.js team seems to put quite a focus on Worker Threads though and lately, Node.js changelog often mentions Worker Threads. Before, we needed to run Node with an additional flag,  ",(0,o.jsx)(t.code,{children:"\u2014experimental-worker"}),", but not anymore."]}),"\n",(0,o.jsxs)(t.p,{children:["With the ",(0,o.jsx)(t.code,{children:"new Worker"}),", we create a Worker in a similar way that we create a child process."]}),"\n",(0,o.jsxs)(t.p,{children:["The only issue that we encounter is the lack of support for ",(0,o.jsx)(t.code,{children:".ts"})," files. When using the child process module, the new process inherits the ",(0,o.jsx)(t.code,{children:"process.execArgv"})," property and therefore it runs with TypeScript. Currently, it is not the case with Worker Threads. Trying to run a ",(0,o.jsx)(t.code,{children:".ts"})," file in a worker thread results in error:"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"The worker script extension must be \u201c.js\u201d or \u201c.mjs\u201d. Received \u201c.ts\u201d"}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["As of now, the only way to overcome this issue is to import  .js files. There are a few approaches that we can take with this problem, for example creating a  .js file for every worker that we want to use ",(0,o.jsx)(t.a,{href:"https://github.com/TypeStrong/ts-node/issues/676#issuecomment-470898116",children:"as suggested on GitHub"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",metastring:'title="worker.js"',children:"const path = require('path');\n \nrequire('ts-node').register();\nrequire(path.resolve(__dirname, './worker.ts'));\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Thanks to using ",(0,o.jsx)(t.code,{children:"require('ts-node').register()"}),", the ",(0,o.jsx)(t.code,{children:"worker.ts"})," file is compiled to TypeScript."]}),"\n",(0,o.jsxs)(t.p,{children:["The above means quite a lot of redundant code because we need to create an additional ",(0,o.jsx)(t.code,{children:".js"}),"  file for every worker. We can improve by passing a file name to the ",(0,o.jsx)(t.code,{children:"worker.js"})," file using ",(0,o.jsx)(t.code,{children:"workerData"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"communicating-between-threads",children:"Communicating between threads"}),"\n",(0,o.jsxs)(t.p,{children:["We can use the ",(0,o.jsx)(t.code,{children:"workerData"})," parameter to send data to the newly created worker. It can be ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm",children:"any value that can be cloned by the structured clone algorithm"})," \u2013 the workers receive cloned value. The above puts a few constraints on what we pass as the  ",(0,o.jsx)(t.code,{children:"workerData"}),". For example, we can\u2019t pass functions to it. Let\u2019s use it to give the path of our  ",(0,o.jsx)(t.code,{children:".ts"})," file to ",(0,o.jsx)(t.code,{children:"worker.js"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="main.ts"',children:"import { Worker } from 'worker_threads';\n \nconst worker = new Worker('./worker.js', {\n  workerData: {\n    path: './worker.ts'\n  }\n});\n"})}),"\n",(0,o.jsxs)(t.p,{children:["When you are inside of a worker, you can read the ",(0,o.jsx)(t.code,{children:"workerData"})," by importing it from the ",(0,o.jsx)(t.strong,{children:"Worker Threads"})," module. Let\u2019s use it to resolve our ",(0,o.jsx)(t.code,{children:".ts"})," file."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-javascript",metastring:'title="worker.js"',children:"const path = require('path');\nconst { workerData } = require('worker_threads');\n \nrequire('ts-node').register();\nrequire(path.resolve(__dirname, workerData.path));\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Thanks to the code above we have just one  ",(0,o.jsx)(t.code,{children:".js"})," file that imports any  ",(0,o.jsx)(t.code,{children:".ts"})," file so that we can use TypeScript with Worker Threads easily."]}),"\n",(0,o.jsx)(t.p,{children:"Since we got that down, let\u2019s implement a way for the main thread and our worker thread to communicate further."}),"\n",(0,o.jsx)(t.h2,{id:"communicating-with-the-parent-thread",children:"Communicating with the parent thread"}),"\n",(0,o.jsxs)(t.p,{children:["The easiest way to communicate the worker thread with the main thread is to use  ",(0,o.jsx)(t.code,{children:"parentPort"})," that can be imported inside of a worker. You can send any data as long as it is compatible with the ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm",children:"HTML structured clone algorithm"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="worker.ts"',children:"import { parentPort, workerData } from 'worker_threads';\n \nfunction factorial(n: number): number {\n  if(n === 1 || n === 0){\n    return 1;\n  }\n  return factorial(n - 1) * n;\n}\n \nparentPort.postMessage(\n  factorial(workerData.value)\n);\n"})}),"\n",(0,o.jsxs)(t.p,{children:["In the code above we use the ",(0,o.jsx)(t.code,{children:"postMessage"})," function to send data back to the main thread. A way to receive it is to listen for the ",(0,o.jsx)(t.strong,{children:"message"})," event:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",metastring:'title="main.ts"',children:"import { Worker } from 'worker_threads';\n \nconst worker = new Worker('./worker.js', {\n  workerData: {\n    value: 15,\n    path: './worker.ts'\n  }\n});\n \nworker.on('message', (result) => {\n  console.log(result);\n});\n"})}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"> 1307674368000\n"})}),"\n",(0,o.jsx)(t.p,{children:"And thanks to the code above we have our main thread communicating with the worker that is written in TypeScript!"}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(t.p,{children:["In this article, we\u2019ve covered the very basics of using TypeScript Worker Threads. To do this, we first had to figure out how to make them work with TypeScript. We also used the  ",(0,o.jsx)(t.code,{children:"parentPort"})," to communicate our worker thread with the main thread, therefore making our code fully functional. In the upcoming article, we dive deeper into this topic by creating our own ports using the ",(0,o.jsx)(t.code,{children:"MessageChannel"})," and share the data between threads."]})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}}}]);