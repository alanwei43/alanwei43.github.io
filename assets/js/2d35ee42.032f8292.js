"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[96005],{13064:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>h,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"nodejs-typescript/sending-data-worker-threads","title":"Sending data between Worker Threads","description":"\u672c\u6587\u8f6c\u8f7d\u81ea Node.js TypeScript #13. Sending data between Worker Threads","source":"@site/src/docs/articles/nodejs-typescript/13-sending-data-worker-threads.md","sourceDirName":"nodejs-typescript","slug":"/nodejs-typescript/sending-data-worker-threads","permalink":"/docs/articles/nodejs-typescript/sending-data-worker-threads","draft":false,"unlisted":false,"editUrl":"https://github.com/alanwei43/blog/tree/master/src/docs/articles/nodejs-typescript/13-sending-data-worker-threads.md","tags":[{"inline":true,"label":"typescript","permalink":"/docs/articles/tags/typescript"},{"inline":true,"label":"node.js","permalink":"/docs/articles/tags/node-js"}],"version":"current","lastUpdatedAt":1662779172000,"sidebarPosition":13,"frontMatter":{"title":"Sending data between Worker Threads","tags":["typescript","node.js"]},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to Worker Threads with TypeScript","permalink":"/docs/articles/nodejs-typescript/worker-threads"},"next":{"title":"Vim Tricks","permalink":"/docs/articles/vim-tricks/"}}');var s=t(74848),a=t(28453);const o={title:"Sending data between Worker Threads",tags:["typescript","node.js"]},i=void 0,h={},d=[{value:"Communicating using the MessageChannel",id:"communicating-using-the-messagechannel",level:2},{value:"Creating a new MessageChannel",id:"creating-a-new-messagechannel",level:3},{value:"Sending MessagePort through a transferList",id:"sending-messageport-through-a-transferlist",level:3},{value:"Different ways of sending the data",id:"different-ways-of-sending-the-data",level:2},{value:"Sending MessagePort through transferList",id:"sending-messageport-through-transferlist",level:3},{value:"Sending ArrayBuffers",id:"sending-arraybuffers",level:3},{value:"Sharing the data using SharedArrayBuffer",id:"sharing-the-data-using-sharedarraybuffer",level:3},{value:"Summary",id:"summary",level:2}];function c(e){const r={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.admonition,{type:"note",children:(0,s.jsxs)(r.p,{children:["\u672c\u6587\u8f6c\u8f7d\u81ea ",(0,s.jsx)(r.a,{href:"https://wanago.io/2019/05/13/node-js-typescript-13-sending-data-worker-threads/",children:"Node.js TypeScript #13. Sending data between Worker Threads"})]})}),"\n",(0,s.jsx)(r.p,{children:"The Worker Threads give us quite exciting features when compared to, for example, child processes. In this article, we create our instances of the MessageChannel to communicate with the Worker Threads. Aside from that, we also share the data between them: it\u2019s something that is not possible with child processes."}),"\n",(0,s.jsx)(r.h2,{id:"communicating-using-the-messagechannel",children:"Communicating using the MessageChannel"}),"\n",(0,s.jsxs)(r.p,{children:["There are a few ways to communicate with Node.js Worker Threads. In the previous part of this series, aside from passing the data through ",(0,s.jsx)(r.code,{children:"workerData"}),", we\u2019ve used the ",(0,s.jsx)(r.code,{children:"parentPort"})," to send the data from the worker thread to the parent."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="worker.ts"',children:"import { parentPort, workerData } from 'worker_threads';\n \nfunction factorial(n: number): number {\n  if(n === 1 || n === 0){\n    return 1;\n  }\n  return factorial(n - 1) * n;\n}\n \nparentPort.postMessage(\n  factorial(workerData.value)\n);\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="main.ts"',children:"import { Worker } from 'worker_threads';\n \nconst worker = new Worker('./worker.js', {\n  workerData: {\n    value: 15,\n    path: './worker.ts'\n  }\n});\n \nworker.on('message', (result) => {\n  console.log(result);\n});\n"})}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:["In the example above we pass two different paths, both to ",(0,s.jsx)(r.code,{children:"worker.js"})," and ",(0,s.jsx)(r.code,{children:"worker.ts"}),". This is connected to the fact that we can\u2019t as of now create worker threads purely from TypeScript files. For more information check out the previous part of this series."]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"While this is a perfectly fine solution, there is more to it. We can create our ports if we find ourselves in a situation requiring a more complex solution."}),"\n",(0,s.jsx)(r.h3,{id:"creating-a-new-messagechannel",children:"Creating a new MessageChannel"}),"\n",(0,s.jsxs)(r.p,{children:["A surprising fact is that the MessageChannel does not have any methods on its own. The only two properties it has are ",(0,s.jsx)(r.code,{children:"port1"})," and ",(0,s.jsx)(r.code,{children:"port2"}),", both instances of MessagePort."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"import { MessageChannel } from 'worker_threads';\n \nconst { port1, port2 } = new MessageChannel();\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Each one of the ports represents one end of the communication channel. Since the ",(0,s.jsx)(r.code,{children:"parentPort"})," is also an instance of the MessagePort, we can guess that our new ports also have the ",(0,s.jsx)(r.code,{children:"postMessage"})," function."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"import { MessageChannel } from 'worker_threads';\n \nconst { port1, port2 } = new MessageChannel();\n \nport1.postMessage('Hello world!');\n \nport2.on('message', (message) => {\n  console.log(message);\n});\n"})}),"\n",(0,s.jsx)(r.p,{children:"The MessageChannel is capable of working without involving any Worker Threads, as in the example above. To fully understand their purpose, let\u2019s use them with a worker."}),"\n",(0,s.jsx)(r.h3,{id:"sending-messageport-through-a-transferlist",children:"Sending MessagePort through a transferList"}),"\n",(0,s.jsx)(r.p,{children:"To set up such communication, we need to send one of the ports to the other thread, while listening to messages on the other end."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="main.ts"',children:"import { Worker, MessageChannel } from 'worker_threads';\nconst { port1, port2 } = new MessageChannel();\n \nconst worker = new Worker('./worker.js', {\n  workerData: {\n    path: './worker.ts'\n  }\n});\n \nport1.on('message', (result) => {\n  console.log(result);\n});\n \nworker.postMessage({ port: port2, value: 15 });\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="worker.ts"',children:"import { parentPort } from 'worker_threads';\nimport Data from './Data';\n \nfunction factorial(n: number): number {\n  if(n === 1 || n === 0){\n    return 1;\n  }\n  return factorial(n - 1) * n;\n}\n \nparentPort.on('message', (data: Data) => {\n  const { port } = data;\n  port.postMessage(factorial(data.value));\n});\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="Data.ts"',children:"import { MessagePort } from 'worker_threads';\n \nexport default interface Data {\n  port: MessagePort;\n  value: number;\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"Well, almost there! Running the above code results in an error:"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"MessagePort was found in message but not listed in transferList"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"different-ways-of-sending-the-data",children:"Different ways of sending the data"}),"\n",(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"transferList"})," that the error mentions is an additional argument of the ",(0,s.jsx)(r.code,{children:"postMessage"})," function. The above is connected to how the ",(0,s.jsx)(r.code,{children:"postMessage"})," function works. By default, it creates a clone of the data that we send, but we can change that behavior with the ",(0,s.jsx)(r.code,{children:"transferList"}),". This is enforced if we use MessagePort. Let\u2019s improve the example from above:"]}),"\n",(0,s.jsx)(r.h3,{id:"sending-messageport-through-transferlist",children:"Sending MessagePort through transferList"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="main.ts"',children:"import { Worker, MessageChannel } from 'worker_threads';\nconst { port1, port2 } = new MessageChannel();\n \nconst worker = new Worker('./worker.js', {\n  workerData: {\n    path: './worker.ts'\n  }\n});\n \nport1.on('message', (result) => {\n  console.log(result);\n});\n \nworker.postMessage({ port: port2, value: 15 }, [port2]);\n"})}),"\n",(0,s.jsxs)(r.p,{children:["Now we explicitly state that we don\u2019t want a clone of the  ",(0,s.jsx)(r.code,{children:"port2"}),". Thanks to that, we pass an original object to the worker."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"worker.postMessage({ port: port2, value: 15 }, [port2]);\n"})}),"\n",(0,s.jsx)(r.p,{children:"The MessageChannel might prove to be useful with more complex algorithms where we create multiple threads and would like to message the main thread from one of our nested Worker Threads."}),"\n",(0,s.jsx)(r.h3,{id:"sending-arraybuffers",children:"Sending ArrayBuffers"}),"\n",(0,s.jsx)(r.p,{children:"In the previous examples, we send elementary data like a number. Nothing restraints us from sending more complex data structures."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-javascript",children:"const numbers = [ 11, 12, 13, 14, 15 ];\n \nworker.postMessage({ port: port2, value: numbers }, [port2]);\n"})}),"\n",(0,s.jsxs)(r.p,{children:["It works without issues, but in the example above the ",(0,s.jsx)(r.code,{children:"numbers"}),", array is cloned. The more complex the data structure, the more computing power it takes to clone it."]}),"\n",(0,s.jsxs)(r.p,{children:["We can prevent that from happening. To do that, we need to use the ",(0,s.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",children:"ArrayBuffer"})," that differs a bit from the Buffer that we cover in the ",(0,s.jsx)(r.a,{href:"https://wanago.io/2019/02/25/node-js-typescript-3-the-buffer/",children:"third part of this series"}),". One of the easiest ways to create it is to use an ",(0,s.jsx)(r.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",children:"Uint8Array"})," that represents an array of 8-bit unsigned integers."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const array = new Uint8Array([ 11, 12, 13, 14, 15 ]);\n \nworker.postMessage({ port: port2, value: array }, [port2, array.buffer]);\n"})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",metastring:'title="worker.ts"',children:"parentPort.on('message', (data: Data) => {\n  const { port, value } = data;\n  value.forEach((number => {\n    port.postMessage(factorial(number));\n  }))\n});\n"})}),"\n",(0,s.jsxs)(r.p,{children:["As you can see, the ArrayBuffer buffer that we need is in the ",(0,s.jsx)(r.code,{children:"array.buffer"})," property. Since we operate on bytes here, we need to be aware of the restraints. Let\u2019s look at how the number 256 is represented in binary:\n",(0,s.jsx)(r.img,{src:"https://wanago.io/wp-content/uploads/2019/05/binary.png",alt:"binary.png"})]}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsx)(r.p,{children:"2\u2078  = 256"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"When we look at the example above we can figure out that the number 256 does not fit into eight bit.Uint8Array ignores excess data and due to that, 256 equals 0. You can use Uint16Array instead, but keep in mind that every element of that array uses more memory."}),"\n",(0,s.jsx)(r.p,{children:"A crucial thing is that when we transfer the buffer and append it to the transferList, it is no longer available to the sender."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const array = new Uint8Array([ 11, 12, 13, 14, 15 ]);\n \nworker.postMessage({ port: port2, value: array }, [port2, array.buffer]);\n \nconsole.log(array.buffer);\n\n//> TypeError: Cannot perform Construct on a neutered ArrayBuffer\n"})}),"\n",(0,s.jsxs)(r.p,{children:["The above is a mechanism implemented to guarantee no race conditions between 2 different threads trying to access the same chunk of memory. It is a fundamental issue with multithreading that is tackled in multiple ways in the multithreading world \u2013 for example with ",(0,s.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Lock_(computer_science)",children:"locks"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"sharing-the-data-using-sharedarraybuffer",children:"Sharing the data using SharedArrayBuffer"}),"\n",(0,s.jsxs)(r.p,{children:["The above restraint, while preventing us from destroying our data, has a workaround. When using Worker Threads, we can designate a piece of memory accessible for more than one thread. To do that, we need to create Uint8Array using a special type of a buffer called ",(0,s.jsx)(r.code,{children:"SharedArrayBuffer"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-typescript",children:"const sharedArrayBuffer = new SharedArrayBuffer(2);\nconst array = new Uint8Array(sharedArrayBuffer);\narray[0] = 11;\narray[1] = 12;\n \nworker.postMessage({ port: port2, value: array }, [port2]);\n"})}),"\n",(0,s.jsx)(r.p,{children:"This way the array is neither cloned, nor it is unavailable to the sender. We need to be especially careful though we stripped ourselves from the built-in mechanism that keeps the integrity of the data. You risk changing a value in one thread and expecting it to be something else in another thread."}),"\n",(0,s.jsxs)(r.p,{children:["Sharing arrays can come in handy, but in TypeScript, we use lots of objects. Currently, ECMA Script does not contain shared objects, but we can ",(0,s.jsx)(r.a,{href:"https://stackoverflow.com/questions/51053222/nodejs-worker-threads-shared-object-store",children:"imitate similar behavior using DataView"}),"."]}),"\n",(0,s.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(r.p,{children:["In this article, we dived deeper into Node.js Worker Threads, focusing on how can we communicate between Worker Threads and send data. We used MessageChannel to create a two-way communication channel between Node.js Worker Threads. Aside from that, we implemented different approaches to sending data between threads. It included cloning, sharing the data between multiple threads and restricting the access to just one thread through the ",(0,s.jsx)(r.code,{children:"transferList"}),"."]})]})}function l(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>o,x:()=>i});var n=t(96540);const s={},a=n.createContext(s);function o(e){const r=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(a.Provider,{value:r},e.children)}}}]);