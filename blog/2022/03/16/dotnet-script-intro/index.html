<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Alan's Blog Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Alan's Blog Blog Atom Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WSJXZXE31N"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-WSJXZXE31N",{anonymize_ip:!0})</script>
<link rel="search" type="application/opensearchdescription+xml" title="Alan's Blog" href="/opensearch.xml">
<script src="/scripts/baidu.js"></script><title data-react-helmet="true">dotnet script 简介  -  Alan&#x27;s Blog</title><meta data-react-helmet="true" property="og:title" content="dotnet script 简介  -  Alan&#x27;s Blog"><meta data-react-helmet="true" name="description" content="描述信息，默认为文章第一段"><meta data-react-helmet="true" property="og:description" content="描述信息，默认为文章第一段"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="preconnect" href="https://0W0V494VRF-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/styles.a44636e0.css">
<link rel="preload" href="/styles.f9cde424.js" as="script">
<link rel="preload" href="/runtime~main.6cdfbfa8.js" as="script">
<link rel="preload" href="/main.d70243fd.js" as="script">
<link rel="preload" href="/1.b1085204.js" as="script">
<link rel="preload" href="/2.66a25161.js" as="script">
<link rel="preload" href="/3.aaa86cf7.js" as="script">
<link rel="preload" href="/01a85c17.7b73c082.js" as="script">
<link rel="preload" href="/033789e8.aa661bc6.js" as="script">
<link rel="preload" href="/486.2b895526.js" as="script">
<link rel="preload" href="/1c4cf7be.cde5fa16.js" as="script">
<link rel="preload" href="/1df93b7f.322ef516.js" as="script">
<link rel="preload" href="/6875c492.60acc5ea.js" as="script">
<link rel="preload" href="/a6aa9e1f.119befbb.js" as="script">
<link rel="preload" href="/b4052de7.938f57e7.js" as="script">
<link rel="preload" href="/ccc49370.0ba683b5.js" as="script">
<link rel="preload" href="/0396100f.477188cc.js" as="script">
<link rel="preload" href="/4635f3f2.1f0fe2ef.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top navbarHideable_17Wu navbarHidden_19ww"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Alan&#x27;s Blog</strong></a><a class="navbar__item navbar__link" href="/docs/">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">博客</a><a class="navbar__item navbar__link" href="/me">关于我</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span></button></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.png" alt="logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">Alan&#x27;s Blog</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">文档</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/blog">博客</a></li><li class="menu__list-item"><a class="menu__link" href="/me">关于我</a></li><li class="menu__list-item"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper blog-wrapper"><div class="container margin-vert--lg"><div class="row"><div class="col col--2"><div class="sidebar_1wv2 thin-scrollbar"><h3 class="sidebarItemTitle_3lOc">热门博文</h3><ul class="sidebarItemList_2WIo"><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/tags">Tags列表</a></li><li class="sidebarItem_iPNH"><a aria-current="page" class="sidebarItemLink_2E17 sidebarItemLinkActive_2Dvr" href="/blog/2022/03/16/dotnet-script-intro">dotnet script 简介</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/16/dotnet-starter">.Net Core QA</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/16/get-public-ip-using-curl">使用curl命令行获取当前机器公网IP</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/12/caddy-intro">Caddy 简介</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/12/docker-history-full-command">docker history命令显示完整信息</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/12/macos-security-allow-apps-anywhere">macOS系统安全隐私设置允许任意源下载的App</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/10/spring-both-support-json-url-encoded">Spring 接口同时支持JSON数据和Form表单数据</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/08/node-child-process-memory">Node调整child_process内存大小</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/04/git-remove-untrack-files">Git 删除未跟踪文件</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/03/01/spring-response-image">Spring 响应图片等媒体数据</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/02/27/vmware-vmrun-cli">VMware 命令行操作虚拟机</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/02/27/vmware-workstation-pro-keys">VMware Workstation Pro keys</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/02/27/windows-vmware-tools-drive-fail">VMware的Windows虚拟机中因驱动签名问题无法安装 VMware Tools</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/02/26/docker-dockerfile-intro">Dockerfile 常用指令介绍</a></li><li class="sidebarItem_iPNH"><a class="sidebarItemLink_2E17" href="/blog/2022/02/24/idea-lombok">解决IDEA使用低版本lombok没有get/set方法问题</a></li></ul></div></div><main class="col col--8"><article><header><h1 class="margin-bottom--lg blogPostTitle_kDB-">dotnet script 简介</h1><div><time datetime="2022-03-16T00:00:00.000Z" class="blogPostDate_2HVl">March 16, 2022  · 11 min read</time></div><div class="avatar margin-vert--md"><a class="avatar__photo-link avatar__photo" href="https://github.com/alanwei43" target="_blank" rel="noreferrer noopener"><img src="https://avatars.githubusercontent.com/u/2927578?s=460&amp;u=153132e7aa3be8295a1703af9b759ca22338f557&amp;v=4" alt="Alan"></a><div class="avatar__intro"><h4 class="avatar__name"><a href="https://github.com/alanwei43" target="_blank" rel="noreferrer noopener">Alan</a></h4><small class="avatar__subtitle">Maintainer of blog</small></div></div></header><section class="markdown"><p>.Net Core 工具 <code>dotnet-script</code> 简介</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="总结"></a>总结<a class="hash-link" href="#总结" title="Direct link to heading">#</a></h2><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token operator">&gt;</span><span class="token plain"> dotnet tool </span><span class="token function" style="color:rgb(80, 250, 123)">install</span><span class="token plain"> -g dotnet-script  </span><span class="token comment" style="color:rgb(98, 114, 164)"># 安装 dotnet-script</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script --help </span><span class="token comment" style="color:rgb(98, 114, 164)"># 显示帮助文档</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script init </span><span class="token comment" style="color:rgb(98, 114, 164)"># 创建脚手架脚本</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script </span><span class="token comment" style="color:rgb(98, 114, 164)"># 进入 REPL 模式</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script hello.csx -i </span><span class="token comment" style="color:rgb(98, 114, 164)"># 执行脚本 hell.csx 后进入 REPL 模式</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script hello.csx </span><span class="token comment" style="color:rgb(98, 114, 164)"># 执行脚本 hello.csx</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script -d hello.csx </span><span class="token comment" style="color:rgb(98, 114, 164)"># 以debug模式执行脚本 hello.csx</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script -d hello.csx -- arg1 arg2 </span><span class="token comment" style="color:rgb(98, 114, 164)"># 以debug模式执行脚本 hello.csx, 并传入两个参数: arg1, arg2. 脚本内部使用全局变量 Args 接收参数.</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script hello.csx -s https://SomePackageSource1 -s https://SomePackageSource2 </span><span class="token comment" style="color:rgb(98, 114, 164)"># 执行脚本时指定多个Nuget包源地址</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script https://dwz.cn/xpsKTaoi </span><span class="token comment" style="color:rgb(98, 114, 164)"># 执行远程脚本</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">ls</span><span class="token plain"> -al </span><span class="token operator">|</span><span class="token plain"> dotnet script UpperCase.csx </span><span class="token comment" style="color:rgb(98, 114, 164)"># 接收管道输入</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script </span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">exec</span><span class="token plain"> path_to_dll -- arg1 arg2 </span><span class="token comment" style="color:rgb(98, 114, 164)"># 执行 dll 文件, 并传入两个参数: arg1, arg2.</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token operator">&gt;</span><span class="token plain"> dotnet script publish main.csx -o publish_dir -c Release </span><span class="token comment" style="color:rgb(98, 114, 164)"># 编译脚本为独立可执行程序</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>脚本内指令:</p><ul><li>首行加入 <code>#!/usr/bin/env dotnet-script</code>, 并把脚本文件更改为可执行文件, 可以直接执行.</li><li><code>#r &quot;nuget: Newtonsoft.Json, 12.0.2&quot;</code> 引用nuget包</li><li><code>#load &quot;nuget:simple-targets-csx, 6.0.0&quot;</code> 引用nuget上的脚本包</li><li><code>#load &quot;./other-script.csx&quot;</code> 引用其他脚本文件</li></ul><p>来源 <a href="https://github.com/filipw/dotnet-script/blob/master/README.md" target="_blank" rel="noopener noreferrer">filipw/dotnet-script</a></p><p>使用.Net CLI运行C#脚本, 使用VS Code编辑脚本并引用Nuget包. 所有OmniSharp支持的语言都支持这些特性.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="安装"></a>安装<a class="hash-link" href="#安装" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="要求"></a>要求<a class="hash-link" href="#要求" title="Direct link to heading">#</a></h3><p>我们只需要安装 <a href="https://www.microsoft.com/net/download/core" target="_blank" rel="noopener noreferrer">.Net Core 2.1+ SDK</a> 即可.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="net-core-21-global-tool"></a>.Net Core 2.1 Global Tool<a class="hash-link" href="#net-core-21-global-tool" title="Direct link to heading">#</a></h3><p>.Net Core 2.1 增加了全局工具(global tool)的概念, 这意味着你只需要.Net CLI就可以安装 <code>dotnet-script</code>. </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token operator">&gt;</span><span class="token plain"> dotnet tool </span><span class="token function" style="color:rgb(80, 250, 123)">install</span><span class="token plain"> -g dotnet-script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Tools directory </span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;/Users/alan/.dotnet/tools&#x27;</span><span class="token plain"> is not currently on the </span><span class="token environment constant" style="color:rgb(189, 147, 249)">PATH</span><span class="token plain"> environment variable.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">If you are using bash, you can </span><span class="token function" style="color:rgb(80, 250, 123)">add</span><span class="token plain"> it to your profile by running the following command:</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token function" style="color:rgb(80, 250, 123)">cat</span><span class="token plain"> </span><span class="token operator">&lt;&lt;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">\</span><span class="token plain">EOF </span><span class="token operator">&gt;&gt;</span><span class="token plain"> ~/.bash_profile</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token comment" style="color:rgb(98, 114, 164)"># Add .NET Core SDK tools</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">export</span><span class="token plain"> </span><span class="token assign-left variable environment constant" style="color:rgb(189, 147, 249);font-style:italic">PATH</span><span class="token operator">=</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;</span><span class="token string environment constant" style="color:rgb(189, 147, 249)">$PATH</span><span class="token string" style="color:rgb(255, 121, 198)">:/Users/alan/.dotnet/tools&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">EOF</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">You can </span><span class="token function" style="color:rgb(80, 250, 123)">add</span><span class="token plain"> it to the current session by running the following command:</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain"></span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">export</span><span class="token plain"> </span><span class="token assign-left variable environment constant" style="color:rgb(189, 147, 249);font-style:italic">PATH</span><span class="token operator">=</span><span class="token string" style="color:rgb(255, 121, 198)">&quot;</span><span class="token string environment constant" style="color:rgb(189, 147, 249)">$PATH</span><span class="token string" style="color:rgb(255, 121, 198)">:/Users/alan/.dotnet/tools&quot;</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">You can invoke the tool using the following command: dotnet-script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Tool </span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;dotnet-script&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">version </span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;0.29.1&#x27;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> was successfully installed.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这种方式的好处是你可跨平台使用相同的命令安装 <code>dotnet-script</code>.</p><blockquote><p><code>/Users/alan</code> 是我的用户目录, 安装完成后为了方便使用 <code>dotnet-script</code> 命令, 你可以把目录<code>/Users/alan/.dotnet/tools</code>添加到环境变量<code>PATH</code>中, 或者使用<code>ln -s /Users/alan/.dotnet/tools/dotnet-script /usr/local/bin/dotnet-script</code>添加到现有的<code>PATH</code>目录中.</p></blockquote><blockquote><p>使用 .Net CLI 安装完 <code>dotnet-script</code> 后, 需要检查是否添加了<code>DOTNET_ROOT</code>环境变量, 否则执行<code>dotnet-script</code>后会报以下错误: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-bash codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">$ dotnet-script </span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">A fatal error occurred, the required library libhostfxr.dylib could not be found.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">If this is a self-contained application, that library should exist </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">in</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">/Users/alan/.dotnet/tools/.store/dotnet-script/0.29.1/dotnet-script/0.29.1/tools/netcoreapp2.1/any/</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain">.</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">If this is a framework-dependent application, </span><span class="token function" style="color:rgb(80, 250, 123)">install</span><span class="token plain"> the runtime </span><span class="token keyword" style="color:rgb(189, 147, 249);font-style:italic">in</span><span class="token plain"> the default location </span><span class="token punctuation" style="color:rgb(248, 248, 242)">[</span><span class="token plain">/usr/local/share/dotnet</span><span class="token punctuation" style="color:rgb(248, 248, 242)">]</span><span class="token plain"> or use the DOTNET_ROOT environment variable to specify the </span><span class="token operator">&gt;</span><span class="token plain"> runtime location.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>如果你是使用官方安装包(Installer), 而不是下载二进制包(Binaries)安装的.Net Core, 那么安装完成后系统可能就已经增加了<code>DOTNET_ROOT</code>环境变量, 环境变量的值是.Net Core的安装目录, 比如我的系统可能就是 <code>export DOTNET_ROOT=/usr/local/dotnet-sdk-2.2.104</code>. </p></blockquote><p>.NET Core SDK 也支持查看已经安装的工具列表, 以及卸载功能: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet tool list -g</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Package Id         Version      Commands</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">---------------------------------------------</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet-script      </span><span class="token number">0.22</span><span class="token plain">.0       dotnet-script</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet tool uninstall dotnet-script -g</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Tool </span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;dotnet-script&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">version </span><span class="token string" style="color:rgb(255, 121, 198)">&#x27;0.22.0&#x27;</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span><span class="token plain"> was successfully uninstalled.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="windows"></a>Windows<a class="hash-link" href="#windows" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-powershell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">choco install dotnet.script</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我们也提供了PowerShell安装脚本: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-powershell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">(new-object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.ps1&quot;) | iex</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="linux-and-mac"></a>Linux and Mac<a class="hash-link" href="#linux-and-mac" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token function" style="color:rgb(80, 250, 123)">curl</span><span class="token plain"> -s https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.sh </span><span class="token operator">|</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">bash</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>如果权限不允许, 你可以尝试使用<code>sudo</code>: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token function" style="color:rgb(80, 250, 123)">curl</span><span class="token plain"> -s https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.sh </span><span class="token operator">|</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">sudo</span><span class="token plain"> </span><span class="token function" style="color:rgb(80, 250, 123)">bash</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="docker"></a>Docker<a class="hash-link" href="#docker" title="Direct link to heading">#</a></h3><p>在Linux容器中运行 <code>dotnet-script</code> 的 Dockerfile 也是被支持的. 开始构建镜像: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token builtin class-name" style="color:rgb(189, 147, 249)">cd</span><span class="token plain"> build</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">docker build -t dotnet-script -f Dockerfile </span><span class="token punctuation" style="color:rgb(248, 248, 242)">..</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>然后执行: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">docker run -it dotnet-script --version</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="github"></a>Github<a class="hash-link" href="#github" title="Direct link to heading">#</a></h3><p>你也可以从<a href="https://github.com/filipw/dotnet-script/releases" target="_blank" rel="noopener noreferrer">Github releases page</a>手动下载所有<code>zip</code>格式的版本.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="usage"></a>Usage<a class="hash-link" href="#usage" title="Direct link to heading">#</a></h2><p>dotnet script中经典的 <code>helloworld.csx</code> 演示看起来像下面这样:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-cs codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">Console.WriteLine(&quot;Hello world!&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这就已经完成了, 我们可以执行这段脚本了(参数列表可以通过全局的<code>Args</code>数组访问): </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script helloworld.csx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="脚手架"></a>脚手架<a class="hash-link" href="#脚手架" title="Direct link to heading">#</a></h3><p>在你的系统中创建一个文件夹, 然后执行以下命令: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script init</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这会创建一个 <code>main.csx</code> 文件, 和一个可以在VS Code中调试的启动配置文件.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token builtin class-name" style="color:rgb(189, 147, 249)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">├── .vscode</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">│   └── launch.json</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">├── main.csx</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">└── omnisharp.json</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我们也可以使用自定义的文件名来初始化一个文件夹.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script init custom.csx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我们现在有了一个名为 <code>custom.csx</code> 的文件, 取代了之前默认的 <code>main.csx</code> 文件.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token builtin class-name" style="color:rgb(189, 147, 249)">.</span><span class="token plain"></span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">├── .vscode</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">│   └── launch.json</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">├── custom.csx</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">└── omnisharp.json</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><blockquote><p>备注: 在一个包含一个或多个脚本的文件夹执行 <code>dotnet script init</code> 不会创建 <code>main.csx</code> 文件.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="运行脚本"></a>运行脚本<a class="hash-link" href="#运行脚本" title="Direct link to heading">#</a></h3><p>如果脚本是可执行文件, 可以直接通过shell执行.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-bash codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">foo.csx arg1 arg2 arg3</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><blockquote><p>OSX/Linux</p><p>就像所有其他脚本一样, 在 OSX/Linux 系统中, 脚本第一行需要有 <code>!#</code>, 而且必须通过命令 <strong>chmod +x foo.csx</strong> 使文件变成可执行文件.
使用 <strong>dotnet script init</strong> 创建的csx文件会自动添加指令 <code>!#</code> 并标记csx文件为可执行文件.</p></blockquote><p>OSX/Linux 系统的 shebang 指令为 <strong>#!/usr/bin/env dotnet-script</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-cs codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">#!/usr/bin/env dotnet-script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Console.WriteLine(&quot;Hello world&quot;);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>你可以使用 <strong>dotnet script</strong> 或者 <strong>dotnet-script</strong> 来执行你的脚本, 这种方式允许你通过传递参数来控制脚本的执行.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-bash codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">foo.csx arg1 arg2 arg3</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script foo.csx -- arg1 arg2 arg3</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet-script foo.csx -- arg1 arg2 arg3</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="向脚本中传递参数"></a>向脚本中传递参数<a class="hash-link" href="#向脚本中传递参数" title="Direct link to heading">#</a></h4><p>所有 <code>--</code> 后的参数都会被传递给脚本:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script foo.csx -- arg1 arg2 arg3</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>然后你在脚本的上下文中使用全局的<code>Args</code>集合来访问传递进来的参数:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-cs codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">foreach (var arg in Args)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">{</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    Console.WriteLine(arg);</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>所有 <code>--</code> 之前的参数都会交由 <code>dotnet script</code> 处理. 比如下面的命令: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script -d foo.csx -- -d</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><code>--</code> 之前的参数 <code>-d</code> 传递给 <code>dotnet script</code> 用于开启debug模式, 而 <code>--</code> 后面的 <code>-d</code> 会被传递给脚本.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="nuget-包"></a>NuGet 包<a class="hash-link" href="#nuget-包" title="Direct link to heading">#</a></h3><p><code>dotnet script</code> 支持直接在脚本中引用Nuget包(内置功能). </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c# codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">#r &quot;nuget: AutoMapper, 6.1.0&quot;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><img src="https://user-images.githubusercontent.com/1034073/30176983-98a6b85e-9404-11e7-8855-4ae65a20d6b1.gif" alt="package"></p><blockquote><p>备注: 在添加了包引用之后需要重启 Omnisharp .</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="nuget包源"></a>Nuget包源<a class="hash-link" href="#nuget包源" title="Direct link to heading">#</a></h4><p>我们可以直接在脚本根目录的 <code>NuGet.Config</code> 文件中定义包源. 另外在脚本执行时, 会借助提供语言服务的 <code>OmniSharp</code> 进行从包源中进行包解析.</p><p>我们可以在用户级别或者系统级别定义Nuget包源(这里有相关介绍 <a href="https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file" target="_blank" rel="noopener noreferrer">Configuring NuGet Behaviour</a> )来替代本地<code>Nuget.Config</code>维护.</p><p>也可以在执行脚本的时候指定包源.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script foo.csx -s https://SomePackageSource</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>同时指定多个包源: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script foo.csx -s https://SomePackageSource -s https://AnotherPackageSource</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="从csx文件创建dll或者可执行文件"></a>从CSX文件创建DLL或者可执行文件<a class="hash-link" href="#从csx文件创建dll或者可执行文件" title="Direct link to heading">#</a></h3><p>Dotnet-Script 可以为你的脚本创建独立的可执行文件或者DLL文件.</p><p>比如 <code>dotnet script publish main.csx -o publish_dir -c Release -d</code></p><table><thead><tr><th>开关</th><th>对应全称开关名称</th><th>描述</th></tr></thead><tbody><tr><td>-o</td><td>--output</td><td>Directory where the published executable should be placed.  Defaults to a &#x27;publish&#x27; folder in the current directory.</td></tr><tr><td>-n</td><td>--name</td><td>The name for the generated DLL (executable not supported at this time).  Defaults to the name of the script.</td></tr><tr><td></td><td>--dll</td><td>Publish to a .dll instead of an executable.</td></tr><tr><td>-c</td><td>--configuration</td><td>Configuration to use for publishing the script [Release/Debug]. Default is &quot;Debug&quot;</td></tr><tr><td>-d</td><td>--debug</td><td>Enables debug output.</td></tr><tr><td>-r</td><td>--runtime</td><td>The runtime used when publishing the self contained executable. Defaults to your current runtime.</td></tr></tbody></table><p>发布后的可执行文件无需依赖 <code>dotnet install</code> 即可执行. DLL可以使用 .Net CLI 执行:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script </span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">exec</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(248, 248, 242)">{</span><span class="token plain">path_to_dll</span><span class="token punctuation" style="color:rgb(248, 248, 242)">}</span><span class="token plain"> -- arg1 arg2</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="缓存"></a>缓存<a class="hash-link" href="#缓存" title="Direct link to heading">#</a></h3><p>我们提供了两种类型的缓存 <code>dependency cache</code> 和 <code>execution cache</code>. 为了使缓存能够开启, 要求NuGet包引用必须指定确切的版本号. 这个限制的原因是 <del>我们无法执行过时依赖树的脚本?</del> (The reason for this constraint is that we need to make sure that we don&#x27;t execute a script with a stale dependency graph.)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="依赖缓存-dependency-cache"></a>依赖缓存 Dependency Cache<a class="hash-link" href="#依赖缓存-dependency-cache" title="Direct link to heading">#</a></h4><p>为了解决脚本依赖, 在生成 <code>project.assets.json</code> 文件的回调中执行 <code>dotnet restore</code>. <code>project.assets.json</code> 文件指定了所有添加到编译的依赖.</p><p>This is an out-of-process operation and represents a significant overhead to the script execution. So this cache works by looking at all the dependencies specified in the script(s) either in the form of NuGet package references or assembly file references. If these dependencies matches the dependencies from the last script execution, we skip the restore and read the dependencies from the already generated <code>project.assets.json</code> file. If any of the dependencies has changed, we must restore again to obtain the new dependency graph.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="execution-cache"></a>Execution cache<a class="hash-link" href="#execution-cache" title="Direct link to heading">#</a></h4><p>In order to execute a script it needs to be compiled first and since that is a CPU and time consuming operation, we make sure that we only compile when the source code has changed. This works by creating a SHA256 hash from all the script files involved in the execution. This hash is written to a temporary location along with the DLL that represents the result of the script compilation. When a script is executed the hash is computed and compared with the hash from the previous compilation. If they match there is no need to recompile and we run from the already compiled DLL. If the hashes don&#x27;t match, the cache is invalidated and we recompile.</p><blockquote><p>You can override this automatic caching by passing <strong>--nocache</strong> flag, which will bypass both caches and cause dependency resolution and script compilation to happen every time we execute the script.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="调试"></a>调试<a class="hash-link" href="#调试" title="Direct link to heading">#</a></h3><p>使用 <code>Console.WriteLine</code> 进行调试的时代已经过去了. <code>dotnet script</code> 的一个主要特性是能够直接在VS Code中调试脚本. 只需要在你的脚本中设置好断点, 然后按下F5即可调试</p><p><img src="https://user-images.githubusercontent.com/1034073/30173509-2f31596c-93f8-11e7-9124-ca884cf6564e.gif" alt="debug"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="脚本包-script-packages"></a>脚本包 Script Packages<a class="hash-link" href="#脚本包-script-packages" title="Direct link to heading">#</a></h3><p>脚本包是把可复用脚本组织好发布到Nuget包管理, 让其他脚本消费使用. 这意味着我们现在就可以借助现有基础设施而不需要凭借自己的力量从头开始.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="创建脚本包"></a>创建脚本包<a class="hash-link" href="#创建脚本包" title="Direct link to heading">#</a></h4><p>脚本包就是一个常规的Nuget包, 脚本文件包含在 <code>content</code> 或者 <code>contentFiles</code> 文件夹中.</p><p>下面的例子演示了根据<a href="https://docs.microsoft.com/en-us/nuget/schema/nuspec#including-content-files" target="_blank" rel="noopener noreferrer">standard convention</a>脚本包是如何在Nuget中展开的.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">└── contentFiles</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    └── csx</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">        └── netstandard2.0</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">            └── main.csx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这个例子仅仅在根目录包含一个 <code>main.csx</code> 文件. 但是脚本包也许在跟目录或根目录下的子目录中中包含多个文件.</p><p>当加载一个脚本包的时候, 会先寻找入口去加载. 入口脚本是下面其中之一: </p><ul><li>根目录中叫 <code>main.csx</code> 的脚本</li><li>根目录中仅有的脚本文件 </li></ul><p>如果依据以上规则没有找到入口脚本, 会加载包中的所有脚本文件</p><blockquote><p>提供入口脚本的好处是我们可以控制包中其他脚本加载. </p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor" id="消费脚本包"></a>消费脚本包<a class="hash-link" href="#消费脚本包" title="Direct link to heading">#</a></h4><p>消费脚本包, 我们只需要在 <code>#locad </code> 指令中指定Nuget包.</p><p>下面的例子加载 <a href="https://www.nuget.org/packages/simple-targets-csx" target="_blank" rel="noopener noreferrer">simple-targets</a> 包中包含的脚本文件到我们的脚本中. </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-C# codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">#! &quot;netcoreapp2.1&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">#load &quot;nuget:simple-targets-csx, 6.0.0&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">using static SimpleTargets;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">var targets = new TargetDictionary();</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">targets.Add(&quot;default&quot;, () =&gt; Console.WriteLine(&quot;Hello, world!&quot;));</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Run(Args, targets);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><blockquote><p>备注: 调试脚本包也是支持的, 我们可以很容易进入 <code>#load </code> 指令引入的脚本.</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="远程脚本"></a>远程脚本<a class="hash-link" href="#远程脚本" title="Direct link to heading">#</a></h3><p>脚本不需要存在于本机. 我们可以执行<code>http(s)</code>可访问的脚本. </p><p>这意味着我们可以创建Gist, 然后执行: </p><p>这个 <a href="https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx" target="_blank" rel="noopener noreferrer">Gist</a> 包含打印 &quot;Hello World&quot; 字符串的脚本</p><p>我们可以像以下这样执行脚本:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>URL 太长了, 我们可以借助短链服务 <a href="https://tinyurl.com/" target="_blank" rel="noopener noreferrer">TinyURL</a>: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script https://tinyurl.com/y8cda9zt</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="script-location"></a>Script Location<a class="hash-link" href="#script-location" title="Direct link to heading">#</a></h3><p>一个非常常见的场景是我们的逻辑需要关联脚本路径. 我们不想让用户来确定这些路径, 下面提供了脚本当前执行的路径和文件夹: </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c# codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">public static string GetScriptPath([CallerFilePath] string path = null) =&gt; path;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">public static string GetScriptFolder([CallerFilePath] string path = null) =&gt; Path.GetDirectoryName(path);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><blockquote><p>提示: 把这些方法放到一个独立脚本, 作为顶层方法. 然后在你需要访问的脚本文件里通过 <code>#load </code> 指令引用. </p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="repl"></a>REPL<a class="hash-link" href="#repl" title="Direct link to heading">#</a></h2><p>这个版本中包含了C# REPL (Read-Evaluate-Print-Loop). 执行无参数的 <code>dotnet-script</code> 开启 REPL 模式.</p><p>这个交互模式允许你提供单独的C#代码块, 然后按下<kbd>Enter</kbd>立即执行. REPL 和 常规的 CSX 脚本一样使用相同的装配集引用和using语句.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="基本使用"></a>基本使用<a class="hash-link" href="#基本使用" title="Direct link to heading">#</a></h3><p>Once <code>dotnet-script</code> starts you will see a prompt for input. You can start typing C# code there.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; var x = 1;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; x+x</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">2</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>If you submit an unterminated expression into the REPL (no <code>;</code> at the end), it will be evaluated and the result will be serialized using a formatter and printed in the output. This is a bit more interesting than just calling <code>ToString()</code> on the object, because it attempts to capture the actual structure of the object. For example:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; var x = new List&lt;string&gt;();</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; x.Add(&quot;foo&quot;);</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; x</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">List&lt;string&gt;(1) { &quot;foo&quot; }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; x.Add(&quot;bar&quot;);</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; x</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">List&lt;string&gt;(2) { &quot;foo&quot;, &quot;bar&quot; }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="inline-nuget-packages"></a>Inline Nuget packages<a class="hash-link" href="#inline-nuget-packages" title="Direct link to heading">#</a></h3><p>REPL also supports inline Nuget packages - meaning the Nuget packages can be installed into the REPL from <em>within the REPL</em>. This is done via our <code>#r</code> and <code>#load</code> from Nuget support and uses identical syntax.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; #r &quot;nuget: Automapper, 6.1.1&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; using AutoMapper;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; typeof(MapperConfiguration)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">[AutoMapper.MapperConfiguration]</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; #load &quot;nuget: simple-targets-csx, 6.0.0&quot;;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; using static SimpleTargets;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; typeof(TargetDictionary)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">[Submission#0+SimpleTargets+TargetDictionary]</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="multiline-mode"></a>Multiline mode<a class="hash-link" href="#multiline-mode" title="Direct link to heading">#</a></h3><p>Using Roslyn syntax parsing, we also support multiline REPL mode. This means that if you have an uncompleted code block and press <kbd>Enter</kbd>, we will automatically enter the multiline mode. The mode is indicated by the <code>*</code> character. This is particularly useful for declaring classes and other more complex constructs.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; class Foo {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">* public string Bar {get; set;}</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">* }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; var foo = new Foo();</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="repl-commands"></a>REPL commands<a class="hash-link" href="#repl-commands" title="Direct link to heading">#</a></h3><p>Aside from the regular C# script code, you can invoke the following commands (directives) from within the REPL:</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#load</code></td><td>Load a script into the REPL (same as <code>#load</code> usage in CSX)</td></tr><tr><td><code>#r</code></td><td>Load an assembly into the REPL (same as <code>#r</code> usage in CSX)</td></tr><tr><td><code>#reset</code></td><td>Reset the REPL back to initial state (without restarting it)</td></tr><tr><td><code>#cls</code></td><td>Clear the console screen without resetting the REPL state</td></tr><tr><td><code>#exit</code></td><td>Exits the REPL</td></tr></tbody></table><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="seeding-repl-with-a-script"></a>Seeding REPL with a script<a class="hash-link" href="#seeding-repl-with-a-script" title="Direct link to heading">#</a></h3><p>You can execute a CSX script and, at the end of it, drop yourself into the context of the REPL. This way, the REPL becomes &quot;seeded&quot; with your code - all the classes, methods or variables are available in the REPL context. This is achieved by running a script with an <code>-i</code> flag.</p><p>For example, given the following CSX script:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-csharp codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">var msg = &quot;Hello World&quot;;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Console.WriteLine(msg);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>When you run this with the <code>-i</code> flag, <code>Hello World</code> is printed, REPL starts and <code>msg</code> variable is available in the REPL context.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script foo.csx -i</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Hello World</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>You can also seed the REPL from inside the REPL - at any point - by invoking a <code>#load</code> directive pointed at a specific file. For example:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-undefined codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">~$ dotnet script</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt; #load &quot;foo.csx&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Hello World</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">&gt;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="管道"></a>管道<a class="hash-link" href="#管道" title="Direct link to heading">#</a></h2><p>下面的例子演示了如何在脚本中使用输入/输出的管道数据.</p><p><code>UpperCase.csx</code> 脚本简单地把标准输入转换成大写后写入到标准输出中.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-csharp codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">#! &quot;netcoreapp2.1&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">using (var streamReader = new StreamReader(Console.OpenStandardInput()))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">{</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    Write(streamReader.ReadToEnd().ToUpper());</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>我们现在简单地把一个命令的输出转入到我们的脚本中:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token builtin class-name" style="color:rgb(189, 147, 249)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;This is some text&quot;</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> dotnet script UpperCase.csx</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">THIS IS SOME TEXT</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor" id="调试-1"></a>调试<a class="hash-link" href="#调试-1" title="Direct link to heading">#</a></h3><p>The first thing we need to do add the following to the <code>launch.config</code> file that allows VS Code to debug a running process.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-JSON codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">{</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    &quot;name&quot;: &quot;.NET Core Attach&quot;,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    &quot;type&quot;: &quot;coreclr&quot;,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    &quot;request&quot;: &quot;attach&quot;,</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    &quot;processId&quot;: &quot;${command:pickProcess}&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>To debug this script we need a way to attach the debugger in VS Code and to the simplest thing we can do here is to wait for the debugger to attach by adding this method somewhere.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c# codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">public static void WaitForDebugger()</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">{</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    Console.WriteLine(&quot;Attach Debugger (VS Code)&quot;);</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    while(!Debugger.IsAttached)</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    {</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    }</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>To debug the script when executing it from the command line we can do something like</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-c# codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">#! &quot;netcoreapp2.0&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">#r &quot;nuget: NetStandard.Library, 2.0.0&quot;</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">WaitForDebugger();</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">using (var streamReader = new StreamReader(Console.OpenStandardInput()))</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">{</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">    Write(streamReader.ReadToEnd().ToUpper()); // &lt;- SET BREAKPOINT HERE</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>Now when we run the script from the command line we will get</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">$ </span><span class="token builtin class-name" style="color:rgb(189, 147, 249)">echo</span><span class="token plain"> </span><span class="token string" style="color:rgb(255, 121, 198)">&quot;This is some text&quot;</span><span class="token plain"> </span><span class="token operator">|</span><span class="token plain"> dotnet script UpperCase.csx</span></div><div class="token-line" style="color:#F8F8F2"><span class="token plain">Attach Debugger </span><span class="token punctuation" style="color:rgb(248, 248, 242)">(</span><span class="token plain">VS Code</span><span class="token punctuation" style="color:rgb(248, 248, 242)">)</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>This now gives us a chance to attach the debugger before stepping into the script and from VS Code, select the  <code>.NET Core Attach</code> debugger and pick the process that represents the executing script.</p><p>Once that is done we should see out breakpoint being hit.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="configurationdebugrelease"></a>Configuration(Debug/Release)<a class="hash-link" href="#configurationdebugrelease" title="Direct link to heading">#</a></h2><p>By default, scripts will be compiled using the <code>debug</code> configuration. This is to ensure that we can debug a script in VS Code as well as attaching a debugger for long running scripts.</p><p>There are however situations where we might need to execute a script that is compiled with the <code>release</code> configuration. For instance, running benchmarks using <a href="http://benchmarkdotnet.org/" target="_blank" rel="noopener noreferrer">BenchmarkDotNet</a> is not possible unless the script is compiled with the <code>release</code> configuration.</p><p>We can specify this when executing the script.</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-shell codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#F8F8F2;background-color:#282A36"><div class="token-line" style="color:#F8F8F2"><span class="token plain">dotnet script foo.csx -c release</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="team"></a>Team<a class="hash-link" href="#team" title="Direct link to heading">#</a></h2><ul><li><a href="https://github.com/seesharper" target="_blank" rel="noopener noreferrer">Bernhard Richter</a> (<a href="https://twitter.com/bernhardrichter" target="_blank" rel="noopener noreferrer">@bernhardrichter</a>)</li><li><a href="https://github.com/filipw" target="_blank" rel="noopener noreferrer">Filip W</a> (<a href="https://twitter.com/filip_woj" target="_blank" rel="noopener noreferrer">@filip_woj</a>)</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor" id="license"></a>License<a class="hash-link" href="#license" title="Direct link to heading">#</a></h2><p><a href="https://github.com/filipw/dotnet-script/blob/master/LICENSE" target="_blank" rel="noopener noreferrer">MIT License</a> </p></section></article><div><a href="https://github.com/alanwei43/blog/tree/master/src/blog/2022-03-16-dotnet-script-intro.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="margin-vert--xl"><nav class="pagination-nav" aria-label="Blog post page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/03/16/dotnet-starter"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">.Net Core QA »</div></a></div></nav></div></main><div class="col col--2"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#总结" class="table-of-contents__link">总结</a></li><li><a href="#安装" class="table-of-contents__link">安装</a><ul><li><a href="#要求" class="table-of-contents__link">要求</a></li><li><a href="#net-core-21-global-tool" class="table-of-contents__link">.Net Core 2.1 Global Tool</a></li><li><a href="#windows" class="table-of-contents__link">Windows</a></li><li><a href="#linux-and-mac" class="table-of-contents__link">Linux and Mac</a></li><li><a href="#docker" class="table-of-contents__link">Docker</a></li><li><a href="#github" class="table-of-contents__link">Github</a></li></ul></li><li><a href="#usage" class="table-of-contents__link">Usage</a><ul><li><a href="#脚手架" class="table-of-contents__link">脚手架</a></li><li><a href="#运行脚本" class="table-of-contents__link">运行脚本</a></li><li><a href="#nuget-包" class="table-of-contents__link">NuGet 包</a></li><li><a href="#从csx文件创建dll或者可执行文件" class="table-of-contents__link">从CSX文件创建DLL或者可执行文件</a></li><li><a href="#缓存" class="table-of-contents__link">缓存</a></li><li><a href="#调试" class="table-of-contents__link">调试</a></li><li><a href="#脚本包-script-packages" class="table-of-contents__link">脚本包 Script Packages</a></li><li><a href="#远程脚本" class="table-of-contents__link">远程脚本</a></li><li><a href="#script-location" class="table-of-contents__link">Script Location</a></li></ul></li><li><a href="#repl" class="table-of-contents__link">REPL</a><ul><li><a href="#基本使用" class="table-of-contents__link">基本使用</a></li><li><a href="#inline-nuget-packages" class="table-of-contents__link">Inline Nuget packages</a></li><li><a href="#multiline-mode" class="table-of-contents__link">Multiline mode</a></li><li><a href="#repl-commands" class="table-of-contents__link">REPL commands</a></li><li><a href="#seeding-repl-with-a-script" class="table-of-contents__link">Seeding REPL with a script</a></li></ul></li><li><a href="#管道" class="table-of-contents__link">管道</a><ul><li><a href="#调试-1" class="table-of-contents__link">调试</a></li></ul></li><li><a href="#configurationdebugrelease" class="table-of-contents__link">Configuration(Debug/Release)</a></li><li><a href="#team" class="table-of-contents__link">Team</a></li><li><a href="#license" class="table-of-contents__link">License</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">文章列表</h4><ul class="footer__items"><li class="footer__item"> <a class="footer__link-item" href="/docs/articles/es6-in-depth/0-introduction">深入浅出ES6 - InfoQ.cn</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/articles/why-java-sucks-and-csharp-rocks/1-compare-purpose">Why Java Sucks and C# Rocks - 赵劼</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/reading">阅读笔记</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/archives/git-guides">博文归档</a> </li></ul></div><div class="col footer__col"><h4 class="footer__title">文档翻译</h4><ul class="footer__items"><li class="footer__item"> <a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="/docs/guides/blog">Docusaurus Blog</a> </li><li class="footer__item"> <a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="/docs/guides/docs/markdown-features">Docusaurus Markdown</a> </li></ul></div><div class="col footer__col"><h4 class="footer__title">更多</h4><ul class="footer__items"><li class="footer__item"> <a href="https://github.com/alanwei43/node-auto-update" target="_blank" rel="noopener noreferrer" class="footer__link-item">node-auto-update - GitHub</a> </li><li class="footer__item"> <a href="https://github.com/alanwei43/docker-puppeteer" target="_blank" rel="noopener noreferrer" class="footer__link-item">docker-puppeteer - GitHub</a> </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Alan&#x27;s Blog <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer"> </a></div></div></div></footer></div>
<script src="/styles.f9cde424.js"></script>
<script src="/runtime~main.6cdfbfa8.js"></script>
<script src="/main.d70243fd.js"></script>
<script src="/1.b1085204.js"></script>
<script src="/2.66a25161.js"></script>
<script src="/3.aaa86cf7.js"></script>
<script src="/01a85c17.7b73c082.js"></script>
<script src="/033789e8.aa661bc6.js"></script>
<script src="/486.2b895526.js"></script>
<script src="/1c4cf7be.cde5fa16.js"></script>
<script src="/1df93b7f.322ef516.js"></script>
<script src="/6875c492.60acc5ea.js"></script>
<script src="/a6aa9e1f.119befbb.js"></script>
<script src="/b4052de7.938f57e7.js"></script>
<script src="/ccc49370.0ba683b5.js"></script>
<script src="/0396100f.477188cc.js"></script>
<script src="/4635f3f2.1f0fe2ef.js"></script>
</body>
</html>