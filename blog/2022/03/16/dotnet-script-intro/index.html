<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.17">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Alan&#39;s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Alan&#39;s Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Alan&#39;s Blog" href="/opensearch.xml">
<script src="/scripts/baidu.js"></script>
<script src="/scripts/bing-clarity.js"></script><title data-rh="true">.Net Script 简介  -  Alan&#x27;s Blog</title><meta data-rh="true" name="baidu-site-verification" content="code-7RGpEH8jty"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.alanwei.com/blog/2022/03/16/dotnet-script-intro/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content=".Net Script 简介  -  Alan&#x27;s Blog"><meta data-rh="true" name="description" content=".Net Core 工具 dotnet-script 简介"><meta data-rh="true" property="og:description" content=".Net Core 工具 dotnet-script 简介"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-03-16T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/alanwei43"><meta data-rh="true" property="article:tag" content=".net,.net core"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://blog.alanwei.com/blog/2022/03/16/dotnet-script-intro/"><link data-rh="true" rel="alternate" href="https://blog.alanwei.com/blog/2022/03/16/dotnet-script-intro/" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.alanwei.com/blog/2022/03/16/dotnet-script-intro/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://7SQ6A6EP36-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/styles.3fbf6686.css">
<link rel="preload" href="/assets/js/runtime~main.73df28f9.js" as="script">
<link rel="preload" href="/assets/js/main.25a66b22.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top navbarHideable_aKYr"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.png" alt="logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Alan&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">博客</a><a class="navbar__item navbar__link" href="/me/">关于我</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_S7eR toggle_TdHA toggleDisabled_f9M3"><div class="toggleButton_rCf9" role="button" tabindex="-1"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></div><input type="checkbox" class="toggleScreenReader_g2nN" aria-label="Switch between dark and light mode (currently light mode)"></div><div class="searchBox_qEbK"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_a9qW thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_uKok margin-bottom--md">热门博文</div><ul class="sidebarItemList_Kvuv"><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/22/how-to-change-ubuntu-timezone/">如何设置Ubuntu 20.04 的时区</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/21/linux-devices-info/">使用Linux命令行检测硬件信息</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/15/docker-entrypoint-exec-format-error/">Dockerfile 指定 entrypoint 之后运行报 exec format error 错误</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/14/docker-daemon-tcp-port/">开放 docker daemon TCP 端口号 2375</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/11/javascript-video-screenshot/">使用JS对用户选择视频进行截图</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/08/idea-cannot-resolve-symbol/">解决 IDEA 打开Java项目提示 Cannot resolve symbol 问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/06/java-long-to-int/">long 转 int - Java</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/04/ubuntu-there-is-1-zombie-process/">登录 Ubuntu 20.04 LTS 显示 There is 1 zombie process</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/03/ubuntu-install-kvm/">Ubuntu 20.04 安装 KVM</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/05/03/windows-10-key-backup/">Windows 10 密钥查看及备份</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/27/front-end-pv-gif/">埋点使用Gif图片的优点</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/25/linux-reboot-time/">查看Linux系统开机时间</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/22/nodejs-undici-intro/">undici 简介 - Node.js</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/12/git-undo-reset/">取消 git reset 操作</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/9/javascript-array-shuffle/">JavaScript数组乱序</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/9/typescript-declare-window-variables/">TypeScript声明window全局变量</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/6/javascript-cancel-event/">JavaScript 取消事件绑定</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/04/4/javascript-scroll-top-smooth/">JavaScript滚动到页面顶部</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/31/hadoop-hive-spark-intro/">如何用形象的比喻描述大数据的技术生态？Hadoop、Hive、Spark 之间是什么关系？</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/31/large-git-repository.md/">如何解决Git仓库 .git 文件过大问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/27/intel-cpu-numbers/">Intel CPU 名称和编号规范</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/24/flutter-qa/">Flutter QA</a></li><li class="sidebarItem_CF0Q"><a aria-current="page" class="sidebarItemLink_miNk sidebarItemLinkActive_RRTD" href="/blog/2022/03/16/dotnet-script-intro/">.Net Script 简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/16/dotnet-starter/">.Net Core QA</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/16/get-public-ip-using-curl/">使用curl命令行获取当前机器公网IP</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/12/caddy-intro/">Caddy 简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/12/docker-history-full-command/">docker history命令显示完整信息</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/12/macos-security-allow-apps-anywhere/">macOS系统安全隐私设置允许任意源下载的App</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/10/spring-both-support-json-url-encoded/">Spring 接口同时支持JSON数据和Form表单数据</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/08/node-child-process-memory/">Node调整child_process内存大小</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/04/git-remove-untrack-files/">Git 删除未跟踪文件</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/03/01/spring-response-image/">Spring 响应图片等媒体数据</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/27/vmware-vmrun-cli/">VMware 命令行操作虚拟机</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/27/vmware-workstation-pro-keys/">VMware Workstation Pro keys</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/27/windows-vmware-tools-drive-fail/">VMware的Windows虚拟机中因驱动签名问题无法安装 VMware Tools</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/26/docker-dockerfile-intro/">Dockerfile 常用指令介绍</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/24/idea-lombok/">解决IDEA使用低版本lombok没有get/set方法问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/23/retrofit-mock-server/">Mock Retrofit http request</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/20/flutter-remote-debug-android-device/">Flutter远程调试Android设备</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/19/dart-visual-studio-code-settings/">Dart Visual Studio Code 推荐设置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/18/github-qa/">GitHub QA</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/18/windows-virtual-desktop/">Windows 虚拟桌面快捷键</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/16/ubuntu-dpkg-install-dependency/">解决Ubuntu使用dpkg安装deb软件包提示缺少依赖问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/14/oray-box-intro/">蒲公英 X1 简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/12/docker-connect-host/">容器内访问物理网络</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/12/install-docker/">安装或卸载 Docker</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/12/linux-startup-script-crontab/">Linux启动自动执行特定脚本</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/02/6/ubuntu-sqlite3-starter/">Ubuntu 20.04 安装使用 SQLite</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/25/flutter-json-seriealize/">Flutter JSON 序列化</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/24/ssh-no-matching-host-key-type-found/">解决SSH no matching host key type found 问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/15/ubuntu-ssh-connection-refused/">解决 Ubuntu/Debian SSH 连接时返回的 Connection refused</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/10/visual-studio-code-snippets/">VSC常用代码片段</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/08/ubuntu-install-multimia-codecs/">Ubuntu 20.04 LTS 安装多媒体解码库</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/08/vmware-workstation-kernel-module-updater/">解决Ubuntu系统启动 VMware Workstation Pro 提示 Kernel Module Updater 问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/06/jdk-roadmap-download/">JDK LTS 路线图及下载地址</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/01/microsoft-pinyin-date/">微软拼音输入法自定义日期时间格式</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2022/01/01/powershell-qa/">PowerShell 常见问答</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/12/12/tsdoc-config/">API Extractor 使用</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/11/28/typescript-type-define-skills/">TypeScript 类型定义小技巧</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/11/18/book-tu-jie-http/">《图解HTTP》笔记</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/11/13/dotnet-web-api-starter/">创建.Net Web API项目</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/10/16/VMware-fusion-pro/">VMware Fusion Pro 注册码 序列号</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/10/10/react-loop-bind-event/">React事件处理程序箭头函数造成的重复渲染问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/10/07/detect-puppeteer-browse/">检测是否是puppeteer访问以及如何破解</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/10/07/nodejs-stream-pipe-finish/">如何知道 Node.js stream pipe 完成</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/10/06/dom-attributes-in-react-16/">DOM Attributes in React 16</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/08/10/mozilla-firefox-devtool-zoom/">修改火狐浏览器开发者工具字体大小</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/07/04/event-emitters-typescript/">Event Emitters in TypeScript</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/06/27/javascript-create-an-array-with-repeat-element/">JavaScript创建指定数量的重复元素</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/25/kafka-docker-setup/">使用Docker运行Apache Kafka</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/18/bash-shortcuts/">Bash快捷键列表</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/17/mac-xcrun-error/">解决 macOS 系统 xcrun error invalid active developer path 异常</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/17/termux-mirror/">Termux配置清华大学开源镜像</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/09/typescript-type-reference/">一个TypeScript类型复用的小技巧</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/05/macos-allow-apps-from-anywhere/">macOS 允许打开任何位置下载的App</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/05/spring-mvc-custom-handler-interceptor/">使用自定义的Spring MVC处理程序拦截器管理会话</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/05/spring-mvc-handlerinterceptor/">Spring MVC HandlerInterceptor 简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/04/spring-boot-jsp/">Spring Boot 使用 JSP</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/05/01/docusaurus-github-starter/">使用 Docusaurus 结合 GitHub 搭建个人站点</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/27/visual-studio-code-intelligence/">VSC指定类库文件增强智能感知</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/26/termux-remote-access/">Termux远程访问</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/23/语文考试可以写负能量作文吗/">语文考试可以写负能量作文吗</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/15/nginx-rewrite/">Nginx 301重定向域名</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/centos-install-nginx/">CentOS安装Nginx</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/create-windows-service/">创建Windows服务</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/customize-bash-prompt/">自定义Linux Bash终端提示符</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/docker-sentry-deploy/">使用 Docker 部署 Sentry</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/iis-reverse-proxy-url-rewrite/">How to Setup Reverse Proxy on IIS with URL-Rewrite</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/iis-reverse-proxy/">配置IIS反向代理教程</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/linux-show-ssh-connection/">查看当前机器的所有SSH连接</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/node-exec-bash-cmd/">使用 Node.js 执行命令行程序</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/spring-boot-maven-plugin/">Spring Boot Maven 插件使用</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/tcp-proxy-in-windows/">Windows 上的TCP代理设置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/ubuntu-install-root-ca-certificate/">Ubuntu 系统安装根证书</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/ubuntu-starter-scripts/">我的Ubuntu新系统安装脚本</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/why-math-round-return-2-instead-3/">为什么 Math.Round(2.5) 返回 2</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/11/windows-bootable-device/">制作Windows启动盘</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/10/node-require-cache/">Node.js require 缓存</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/03/asp.net-proxy-configuration/">ASP.Net 应用配置HTTP代理</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/03/how-to-create-maven-multi-module-project/">如何使用命令行创建带有多个子模块的Maven项目</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/03/powershell-git-chinese-encode/">解决 Windows 环境中 git log 命令中文编码问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/03/windows-add-programs-to-startup-folder/">添加Windows开启启动程序</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/04/02/docker-timezone/">Docker时区设置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/30/npm-install-eresulve-error/">解决 NPM 安装应用出现 ERESOLVE 错误</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/28/git-tags/">Git Tags 使用简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/26/docker-config-mirror/">Docker配置镜像加速</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/26/open-mirrors/">国内开源镜像站点</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/chromium-command-line-switches/">Chromium 所有开关(flag)列表</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/docusaurus-github-deploy/">Docusaurus 配置 GitHub Action 自动发布</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/frp-eof/">frp连接 EOF 失败问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/linux-all-ps-connection/">linux下查看指定进程的所有连接信息</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/linux-view-port-using/">显示Linux端口占用</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/maven-aliyun/">阿里云Maven镜像</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/node-tls/">解决 Node.js HTTP 请求出现的自签名证书校验失败问题</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/21/npm-taobao/">NPM的淘宝镜像</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/20/visual-studio-code-reveal/">Visual Studio Code 侧边栏定位到当前文件</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/15/chrome-flags/">Chrome flags</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/14/lets-encrypt-ssl-certificate/">Let&#x27;s Encrypt证书申请及配置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/13/back-forward-cache/">浏览器的前进后退缓存机制 Back/forward cache</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/13/macos-change-default-behavior-function-keys/">macOS - 更改功能键的默认行为</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/09/remove-http-request-referrer/">删除HTTP请求头中的 referrer</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/07/bei-cui-cheng-xu-yuan-yi-ji-cheng-xu-yuan-be-cui/">悲催的程序员，以及程序员的悲催</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/07/cong-qian-man/">从前慢</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/create-java-project-use-maven/">使用Maven创建一个Java项目</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/how-can-i-create-an-executable-jar-with-dependencies-using-maven/">如何使用Maven创建可执行的JAR文件</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/ipsec-clients-ikev2/">IKEv2 配置和使用指南</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/ipsec-clients-l2tp/">配置 IPsec/L2TP 客户端</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/ipsec-clients-xauth/">配置 IPsec/XAuth VPN 客户端</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/ipsec-server/">搭建 IPSec 服务</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/sublime-right-click-open/">配置右击使用Sublime打开文件夹</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/06/vsc-code-folding/">VSC代码块折叠</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/05/vsc-code-snippets/">VSC 代码片段介绍</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/05/vsc-markdown-snippets/">Markdown 智能感知插入代码片段</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/04/mac-install-wireguard/">Mac安装Wireguard</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/04/sublime-vim-mode/">Sublime开启Vim模式</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/03/Structure-needs-cleaning/">Linux - Structure needs cleaning</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/03/mac-java-home/">设置Mac系统JAVA_HOME</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/03/03/mac-vsc-path/">设置Mac VSC的code变量</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/02/28/node-hash/">Node.js Hash计算</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/02/24/hot-swapping-in-spring-boot/">Spring Boot Hot Swapping</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2021/02/17/java-network-proxy/">设置Java程序网络代理</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2020/03/20/visual-studio-code-config/">我的 Visual Studio Code 配置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2020/03/20/visual-studio-code-keyboard/">我的 Visual Studio Code 快捷键配置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2019/05/14/asp-net-identity-module/">ASP.Net 身份模块介绍</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2019/03/20/vim-config/">我的Vim配置</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2019/03/06/async/">异步编程简介</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2014/09/09/philosophy-note/">哲学思维讲堂 - 卡尔·雅斯贝尔斯</a></li><li class="sidebarItem_CF0Q"><a class="sidebarItemLink_miNk" href="/blog/2014/09/04/math-physics-diff/">数学系和物理系学生有什么差别？</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_uMeh" itemprop="headline">.Net Script 简介</h1><div class="blogPostData_Vfxe margin-vert--md"><time datetime="2022-03-16T00:00:00.000Z" itemprop="datePublished">March 16, 2022</time> · <!-- -->20 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><span class="avatar__photo-link avatar__photo"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer"><img class="image_o0gy" src="https://avatars.githubusercontent.com/u/2927578?s=460&amp;u=153132e7aa3be8295a1703af9b759ca22338f557&amp;v=4" alt="Alan"></a></span><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Alan</span></a></div><small class="avatar__subtitle" itemprop="description">Maintainer of blog</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>.Net Core 工具 <code>dotnet-script</code> 简介</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="总结">总结<a class="hash-link" href="#总结" title="Direct link to heading">​</a></h2><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet tool </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> -g dotnet-script  </span><span class="token comment" style="color:#999988;font-style:italic"># 安装 dotnet-script</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script --help </span><span class="token comment" style="color:#999988;font-style:italic"># 显示帮助文档</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script init </span><span class="token comment" style="color:#999988;font-style:italic"># 创建脚手架脚本</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script </span><span class="token comment" style="color:#999988;font-style:italic"># 进入 REPL 模式</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script hello.csx -i </span><span class="token comment" style="color:#999988;font-style:italic"># 执行脚本 hell.csx 后进入 REPL 模式</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script hello.csx </span><span class="token comment" style="color:#999988;font-style:italic"># 执行脚本 hello.csx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script -d hello.csx </span><span class="token comment" style="color:#999988;font-style:italic"># 以debug模式执行脚本 hello.csx</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script -d hello.csx -- arg1 arg2 </span><span class="token comment" style="color:#999988;font-style:italic"># 以debug模式执行脚本 hello.csx, 并传入两个参数: arg1, arg2. 脚本内部使用全局变量 Args 接收参数.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script hello.csx -s https://SomePackageSource1 -s https://SomePackageSource2 </span><span class="token comment" style="color:#999988;font-style:italic"># 执行脚本时指定多个Nuget包源地址</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script https://dwz.cn/xpsKTaoi </span><span class="token comment" style="color:#999988;font-style:italic"># 执行远程脚本</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ls</span><span class="token plain"> -al </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> dotnet script UpperCase.csx </span><span class="token comment" style="color:#999988;font-style:italic"># 接收管道输入</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script </span><span class="token builtin class-name">exec</span><span class="token plain"> path_to_dll -- arg1 arg2 </span><span class="token comment" style="color:#999988;font-style:italic"># 执行 dll 文件, 并传入两个参数: arg1, arg2.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet script publish main.csx -o publish_dir -c Release </span><span class="token comment" style="color:#999988;font-style:italic"># 编译脚本为独立可执行程序</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>脚本内指令:</p><ul><li>首行加入 <code>#!/usr/bin/env dotnet-script</code>, 并把脚本文件更改为可执行文件, 可以直接执行.</li><li><code>#r &quot;nuget: Newtonsoft.Json, 12.0.2&quot;</code> 引用nuget包</li><li><code>#load &quot;nuget:simple-targets-csx, 6.0.0&quot;</code> 引用nuget上的脚本包</li><li><code>#load &quot;./other-script.csx&quot;</code> 引用其他脚本文件</li></ul><p>来源 <a href="https://github.com/filipw/dotnet-script/blob/master/README.md" target="_blank" rel="noopener noreferrer">filipw/dotnet-script</a></p><p>使用.Net CLI运行C#脚本, 使用VS Code编辑脚本并引用Nuget包. 所有OmniSharp支持的语言都支持这些特性.</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="安装">安装<a class="hash-link" href="#安装" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="要求">要求<a class="hash-link" href="#要求" title="Direct link to heading">​</a></h3><p>我们只需要安装 <a href="https://www.microsoft.com/net/download/core" target="_blank" rel="noopener noreferrer">.Net Core 2.1+ SDK</a> 即可.</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="net-core-21-global-tool">.Net Core 2.1 Global Tool<a class="hash-link" href="#net-core-21-global-tool" title="Direct link to heading">​</a></h3><p>.Net Core 2.1 增加了全局工具(global tool)的概念, 这意味着你只需要.Net CLI就可以安装 <code>dotnet-script</code>. </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> dotnet tool </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> -g dotnet-script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Tools directory </span><span class="token string" style="color:#e3116c">&#x27;/Users/alan/.dotnet/tools&#x27;</span><span class="token plain"> is not currently on the </span><span class="token environment constant" style="color:#36acaa">PATH</span><span class="token plain"> environment variable.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If you are using bash, you can </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> it to your profile by running the following command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">cat</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;&lt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">\</span><span class="token plain">EOF </span><span class="token operator" style="color:#393A34">&gt;&gt;</span><span class="token plain"> ~/.bash_profile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># Add .NET Core SDK tools</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token builtin class-name">export</span><span class="token plain"> </span><span class="token assign-left variable environment constant" style="color:#36acaa">PATH</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;</span><span class="token string environment constant" style="color:#36acaa">$PATH</span><span class="token string" style="color:#e3116c">:/Users/alan/.dotnet/tools&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EOF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can </span><span class="token function" style="color:#d73a49">add</span><span class="token plain"> it to the current session by running the following command:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token builtin class-name">export</span><span class="token plain"> </span><span class="token assign-left variable environment constant" style="color:#36acaa">PATH</span><span class="token operator" style="color:#393A34">=</span><span class="token string" style="color:#e3116c">&quot;</span><span class="token string environment constant" style="color:#36acaa">$PATH</span><span class="token string" style="color:#e3116c">:/Users/alan/.dotnet/tools&quot;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">You can invoke the tool using the following command: dotnet-script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Tool </span><span class="token string" style="color:#e3116c">&#x27;dotnet-script&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">version </span><span class="token string" style="color:#e3116c">&#x27;0.29.1&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> was successfully installed.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这种方式的好处是你可跨平台使用相同的命令安装 <code>dotnet-script</code>.</p><blockquote><p><code>/Users/alan</code> 是我的用户目录, 安装完成后为了方便使用 <code>dotnet-script</code> 命令, 你可以把目录<code>/Users/alan/.dotnet/tools</code>添加到环境变量<code>PATH</code>中, 或者使用<code>ln -s /Users/alan/.dotnet/tools/dotnet-script /usr/local/bin/dotnet-script</code>添加到现有的<code>PATH</code>目录中.</p></blockquote><blockquote><p>使用 .Net CLI 安装完 <code>dotnet-script</code> 后, 需要检查是否添加了<code>DOTNET_ROOT</code>环境变量, 否则执行<code>dotnet-script</code>后会报以下错误: </p><div class="codeBlockContainer_I0IT language-bash theme-code-block"><div class="codeBlockContent_wNvx bash"><pre tabindex="0" class="prism-code language-bash codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">$ dotnet-script </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">A fatal error occurred, the required library libhostfxr.dylib could not be found.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If this is a self-contained application, that library should exist </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">/Users/alan/.dotnet/tools/.store/dotnet-script/0.29.1/dotnet-script/0.29.1/tools/netcoreapp2.1/any/</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">If this is a framework-dependent application, </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> the runtime </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> the default location </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">/usr/local/share/dotnet</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> or use the DOTNET_ROOT environment variable to specify the </span><span class="token operator" style="color:#393A34">&gt;</span><span class="token plain"> runtime location.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>如果你是使用官方安装包(Installer), 而不是下载二进制包(Binaries)安装的.Net Core, 那么安装完成后系统可能就已经增加了<code>DOTNET_ROOT</code>环境变量, 环境变量的值是.Net Core的安装目录, 比如我的系统可能就是 <code>export DOTNET_ROOT=/usr/local/dotnet-sdk-2.2.104</code>. </p></blockquote><p>.NET Core SDK 也支持查看已经安装的工具列表, 以及卸载功能: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet tool list -g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Package Id         Version      Commands</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">---------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dotnet-script      </span><span class="token number" style="color:#36acaa">0.22</span><span class="token plain">.0       dotnet-script</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet tool uninstall dotnet-script -g</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Tool </span><span class="token string" style="color:#e3116c">&#x27;dotnet-script&#x27;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">version </span><span class="token string" style="color:#e3116c">&#x27;0.22.0&#x27;</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> was successfully uninstalled.</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="windows">Windows<a class="hash-link" href="#windows" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-powershell theme-code-block"><div class="codeBlockContent_wNvx powershell"><pre tabindex="0" class="prism-code language-powershell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">choco install dotnet.script</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们也提供了PowerShell安装脚本: </p><div class="codeBlockContainer_I0IT language-powershell theme-code-block"><div class="codeBlockContent_wNvx powershell"><pre tabindex="0" class="prism-code language-powershell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">(new-object Net.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.ps1&quot;) | iex</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="linux-and-mac">Linux and Mac<a class="hash-link" href="#linux-and-mac" title="Direct link to heading">​</a></h3><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">curl</span><span class="token plain"> -s https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.sh </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">bash</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>如果权限不允许, 你可以尝试使用<code>sudo</code>: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">curl</span><span class="token plain"> -s https://raw.githubusercontent.com/filipw/dotnet-script/master/install/install.sh </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">sudo</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">bash</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="docker">Docker<a class="hash-link" href="#docker" title="Direct link to heading">​</a></h3><p>在Linux容器中运行 <code>dotnet-script</code> 的 Dockerfile 也是被支持的. 开始构建镜像: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">cd</span><span class="token plain"> build</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">docker</span><span class="token plain"> build -t dotnet-script -f Dockerfile </span><span class="token punctuation" style="color:#393A34">..</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>然后执行: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">docker</span><span class="token plain"> run -it dotnet-script --version</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="github">Github<a class="hash-link" href="#github" title="Direct link to heading">​</a></h3><p>你也可以从<a href="https://github.com/filipw/dotnet-script/releases" target="_blank" rel="noopener noreferrer">Github releases page</a>手动下载所有<code>zip</code>格式的版本.</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="usage">Usage<a class="hash-link" href="#usage" title="Direct link to heading">​</a></h2><p>dotnet script中经典的 <code>helloworld.csx</code> 演示看起来像下面这样:</p><div class="codeBlockContainer_I0IT language-cs theme-code-block"><div class="codeBlockContent_wNvx cs"><pre tabindex="0" class="prism-code language-cs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">Console.WriteLine(&quot;Hello world!&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这就已经完成了, 我们可以执行这段脚本了(参数列表可以通过全局的<code>Args</code>数组访问): </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script helloworld.csx</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="脚手架">脚手架<a class="hash-link" href="#脚手架" title="Direct link to heading">​</a></h3><p>在你的系统中创建一个文件夹, 然后执行以下命令: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script init</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这会创建一个 <code>main.csx</code> 文件, 和一个可以在VS Code中调试的启动配置文件.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── .vscode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── launch.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── main.csx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── omnisharp.json</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们也可以使用自定义的文件名来初始化一个文件夹.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script init custom.csx</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们现在有了一个名为 <code>custom.csx</code> 的文件, 取代了之前默认的 <code>main.csx</code> 文件.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">.</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── .vscode</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">│   └── launch.json</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">├── custom.csx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">└── omnisharp.json</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>备注: 在一个包含一个或多个脚本的文件夹执行 <code>dotnet script init</code> 不会创建 <code>main.csx</code> 文件.</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="运行脚本">运行脚本<a class="hash-link" href="#运行脚本" title="Direct link to heading">​</a></h3><p>如果脚本是可执行文件, 可以直接通过shell执行.</p><div class="codeBlockContainer_I0IT language-bash theme-code-block"><div class="codeBlockContent_wNvx bash"><pre tabindex="0" class="prism-code language-bash codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">foo.csx arg1 arg2 arg3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>OSX/Linux</p><p>就像所有其他脚本一样, 在 OSX/Linux 系统中, 脚本第一行需要有 <code>!#</code>, 而且必须通过命令 <strong>chmod +x foo.csx</strong> 使文件变成可执行文件.
使用 <strong>dotnet script init</strong> 创建的csx文件会自动添加指令 <code>!#</code> 并标记csx文件为可执行文件.</p></blockquote><p>OSX/Linux 系统的 shebang 指令为 <strong>#!/usr/bin/env dotnet-script</strong></p><div class="codeBlockContainer_I0IT language-cs theme-code-block"><div class="codeBlockContent_wNvx cs"><pre tabindex="0" class="prism-code language-cs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#!/usr/bin/env dotnet-script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Console.WriteLine(&quot;Hello world&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>你可以使用 <strong>dotnet script</strong> 或者 <strong>dotnet-script</strong> 来执行你的脚本, 这种方式允许你通过传递参数来控制脚本的执行.</p><div class="codeBlockContainer_I0IT language-bash theme-code-block"><div class="codeBlockContent_wNvx bash"><pre tabindex="0" class="prism-code language-bash codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">foo.csx arg1 arg2 arg3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script foo.csx -- arg1 arg2 arg3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dotnet-script foo.csx -- arg1 arg2 arg3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="向脚本中传递参数">向脚本中传递参数<a class="hash-link" href="#向脚本中传递参数" title="Direct link to heading">​</a></h4><p>所有 <code>--</code> 后的参数都会被传递给脚本:</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script foo.csx -- arg1 arg2 arg3</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>然后你在脚本的上下文中使用全局的<code>Args</code>集合来访问传递进来的参数:</p><div class="codeBlockContainer_I0IT language-cs theme-code-block"><div class="codeBlockContent_wNvx cs"><pre tabindex="0" class="prism-code language-cs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">foreach (var arg in Args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Console.WriteLine(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>所有 <code>--</code> 之前的参数都会交由 <code>dotnet script</code> 处理. 比如下面的命令: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script -d foo.csx -- -d</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><code>--</code> 之前的参数 <code>-d</code> 传递给 <code>dotnet script</code> 用于开启debug模式, 而 <code>--</code> 后面的 <code>-d</code> 会被传递给脚本.</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="nuget-包">NuGet 包<a class="hash-link" href="#nuget-包" title="Direct link to heading">​</a></h3><p><code>dotnet script</code> 支持直接在脚本中引用Nuget包(内置功能). </p><div class="codeBlockContainer_I0IT language-c# theme-code-block"><div class="codeBlockContent_wNvx c#"><pre tabindex="0" class="prism-code language-c# codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#r &quot;nuget: AutoMapper, 6.1.0&quot;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://user-images.githubusercontent.com/1034073/30176983-98a6b85e-9404-11e7-8855-4ae65a20d6b1.gif" alt="package"></p><blockquote><p>备注: 在添加了包引用之后需要重启 Omnisharp .</p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="nuget包源">Nuget包源<a class="hash-link" href="#nuget包源" title="Direct link to heading">​</a></h4><p>我们可以直接在脚本根目录的 <code>NuGet.Config</code> 文件中定义包源. 另外在脚本执行时, 会借助提供语言服务的 <code>OmniSharp</code> 进行从包源中进行包解析.</p><p>我们可以在用户级别或者系统级别定义Nuget包源(这里有相关介绍 <a href="https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file" target="_blank" rel="noopener noreferrer">Configuring NuGet Behaviour</a> )来替代本地<code>Nuget.Config</code>维护.</p><p>也可以在执行脚本的时候指定包源.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script foo.csx -s https://SomePackageSource</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>同时指定多个包源: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script foo.csx -s https://SomePackageSource -s https://AnotherPackageSource</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="从csx文件创建dll或者可执行文件">从CSX文件创建DLL或者可执行文件<a class="hash-link" href="#从csx文件创建dll或者可执行文件" title="Direct link to heading">​</a></h3><p>Dotnet-Script 可以为你的脚本创建独立的可执行文件或者DLL文件.</p><p>比如 <code>dotnet script publish main.csx -o publish_dir -c Release -d</code></p><table><thead><tr><th>开关</th><th>对应全称开关名称</th><th>描述</th></tr></thead><tbody><tr><td>-o</td><td>--output</td><td>Directory where the published executable should be placed.  Defaults to a &#x27;publish&#x27; folder in the current directory.</td></tr><tr><td>-n</td><td>--name</td><td>The name for the generated DLL (executable not supported at this time).  Defaults to the name of the script.</td></tr><tr><td></td><td>--dll</td><td>Publish to a .dll instead of an executable.</td></tr><tr><td>-c</td><td>--configuration</td><td>Configuration to use for publishing the script <!-- -->[Release/Debug]<!-- -->. Default is &quot;Debug&quot;</td></tr><tr><td>-d</td><td>--debug</td><td>Enables debug output.</td></tr><tr><td>-r</td><td>--runtime</td><td>The runtime used when publishing the self contained executable. Defaults to your current runtime.</td></tr></tbody></table><p>发布后的可执行文件无需依赖 <code>dotnet install</code> 即可执行. DLL可以使用 .Net CLI 执行:</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script </span><span class="token builtin class-name">exec</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain">path_to_dll</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> -- arg1 arg2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="缓存">缓存<a class="hash-link" href="#缓存" title="Direct link to heading">​</a></h3><p>我们提供了两种类型的缓存 <code>dependency cache</code> 和 <code>execution cache</code>. 为了使缓存能够开启, 要求NuGet包引用必须指定确切的版本号. 这个限制的原因是 <del>我们无法执行过时依赖树的脚本?</del> (The reason for this constraint is that we need to make sure that we don&#x27;t execute a script with a stale dependency graph.)</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="依赖缓存-dependency-cache">依赖缓存 Dependency Cache<a class="hash-link" href="#依赖缓存-dependency-cache" title="Direct link to heading">​</a></h4><p>为了解决脚本依赖, 在生成 <code>project.assets.json</code> 文件的回调中执行 <code>dotnet restore</code>. <code>project.assets.json</code> 文件指定了所有添加到编译的依赖.</p><p>This is an out-of-process operation and represents a significant overhead to the script execution. So this cache works by looking at all the dependencies specified in the script(s) either in the form of NuGet package references or assembly file references. If these dependencies matches the dependencies from the last script execution, we skip the restore and read the dependencies from the already generated <code>project.assets.json</code> file. If any of the dependencies has changed, we must restore again to obtain the new dependency graph.</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="execution-cache">Execution cache<a class="hash-link" href="#execution-cache" title="Direct link to heading">​</a></h4><p>In order to execute a script it needs to be compiled first and since that is a CPU and time consuming operation, we make sure that we only compile when the source code has changed. This works by creating a SHA256 hash from all the script files involved in the execution. This hash is written to a temporary location along with the DLL that represents the result of the script compilation. When a script is executed the hash is computed and compared with the hash from the previous compilation. If they match there is no need to recompile and we run from the already compiled DLL. If the hashes don&#x27;t match, the cache is invalidated and we recompile.</p><blockquote><p>You can override this automatic caching by passing <strong>--nocache</strong> flag, which will bypass both caches and cause dependency resolution and script compilation to happen every time we execute the script.</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="调试">调试<a class="hash-link" href="#调试" title="Direct link to heading">​</a></h3><p>使用 <code>Console.WriteLine</code> 进行调试的时代已经过去了. <code>dotnet script</code> 的一个主要特性是能够直接在VS Code中调试脚本. 只需要在你的脚本中设置好断点, 然后按下F5即可调试</p><p><img src="https://user-images.githubusercontent.com/1034073/30173509-2f31596c-93f8-11e7-9124-ca884cf6564e.gif" alt="debug"></p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="脚本包-script-packages">脚本包 Script Packages<a class="hash-link" href="#脚本包-script-packages" title="Direct link to heading">​</a></h3><p>脚本包是把可复用脚本组织好发布到Nuget包管理, 让其他脚本消费使用. 这意味着我们现在就可以借助现有基础设施而不需要凭借自己的力量从头开始.</p><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="创建脚本包">创建脚本包<a class="hash-link" href="#创建脚本包" title="Direct link to heading">​</a></h4><p>脚本包就是一个常规的Nuget包, 脚本文件包含在 <code>content</code> 或者 <code>contentFiles</code> 文件夹中.</p><p>下面的例子演示了根据<a href="https://docs.microsoft.com/en-us/nuget/schema/nuspec#including-content-files" target="_blank" rel="noopener noreferrer">standard convention</a>脚本包是如何在Nuget中展开的.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">└── contentFiles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    └── csx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        └── netstandard2.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            └── main.csx</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>这个例子仅仅在根目录包含一个 <code>main.csx</code> 文件. 但是脚本包也许在跟目录或根目录下的子目录中中包含多个文件.</p><p>当加载一个脚本包的时候, 会先寻找入口去加载. 入口脚本是下面其中之一: </p><ul><li>根目录中叫 <code>main.csx</code> 的脚本</li><li>根目录中仅有的脚本文件 </li></ul><p>如果依据以上规则没有找到入口脚本, 会加载包中的所有脚本文件</p><blockquote><p>提供入口脚本的好处是我们可以控制包中其他脚本加载. </p></blockquote><h4 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="消费脚本包">消费脚本包<a class="hash-link" href="#消费脚本包" title="Direct link to heading">​</a></h4><p>消费脚本包, 我们只需要在 <code>#locad </code> 指令中指定Nuget包.</p><p>下面的例子加载 <a href="https://www.nuget.org/packages/simple-targets-csx" target="_blank" rel="noopener noreferrer">simple-targets</a> 包中包含的脚本文件到我们的脚本中. </p><div class="codeBlockContainer_I0IT language-C# theme-code-block"><div class="codeBlockContent_wNvx C#"><pre tabindex="0" class="prism-code language-C# codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#! &quot;netcoreapp2.1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#load &quot;nuget:simple-targets-csx, 6.0.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using static SimpleTargets;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">var targets = new TargetDictionary();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">targets.Add(&quot;default&quot;, () =&gt; Console.WriteLine(&quot;Hello, world!&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Run(Args, targets);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>备注: 调试脚本包也是支持的, 我们可以很容易进入 <code>#load </code> 指令引入的脚本.</p></blockquote><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="远程脚本">远程脚本<a class="hash-link" href="#远程脚本" title="Direct link to heading">​</a></h3><p>脚本不需要存在于本机. 我们可以执行<code>http(s)</code>可访问的脚本. </p><p>这意味着我们可以创建Gist, 然后执行: </p><p>这个 <a href="https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx" target="_blank" rel="noopener noreferrer">Gist</a> 包含打印 &quot;Hello World&quot; 字符串的脚本</p><p>我们可以像以下这样执行脚本:</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script https://gist.githubusercontent.com/seesharper/5d6859509ea8364a1fdf66bbf5b7923d/raw/0a32bac2c3ea807f9379a38e251d93e39c8131cb/HelloWorld.csx</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>URL 太长了, 我们可以借助短链服务 <a href="https://tinyurl.com/" target="_blank" rel="noopener noreferrer">TinyURL</a>: </p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script https://tinyurl.com/y8cda9zt</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="script-location">Script Location<a class="hash-link" href="#script-location" title="Direct link to heading">​</a></h3><p>一个非常常见的场景是我们的逻辑需要关联脚本路径. 我们不想让用户来确定这些路径, 下面提供了脚本当前执行的路径和文件夹: </p><div class="codeBlockContainer_I0IT language-c# theme-code-block"><div class="codeBlockContent_wNvx c#"><pre tabindex="0" class="prism-code language-c# codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public static string GetScriptPath([CallerFilePath] string path = null) =&gt; path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static string GetScriptFolder([CallerFilePath] string path = null) =&gt; Path.GetDirectoryName(path);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><blockquote><p>提示: 把这些方法放到一个独立脚本, 作为顶层方法. 然后在你需要访问的脚本文件里通过 <code>#load </code> 指令引用. </p></blockquote><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="repl">REPL<a class="hash-link" href="#repl" title="Direct link to heading">​</a></h2><p>这个版本中包含了C# REPL (Read-Evaluate-Print-Loop). 执行无参数的 <code>dotnet-script</code> 开启 REPL 模式.</p><p>这个交互模式允许你提供单独的C#代码块, 然后按下<kbd>Enter</kbd>立即执行. REPL 和 常规的 CSX 脚本一样使用相同的装配集引用和using语句.</p><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="基本使用">基本使用<a class="hash-link" href="#基本使用" title="Direct link to heading">​</a></h3><p>Once <code>dotnet-script</code> starts you will see a prompt for input. You can start typing C# code there.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; var x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; x+x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>If you submit an unterminated expression into the REPL (no <code>;</code> at the end), it will be evaluated and the result will be serialized using a formatter and printed in the output. This is a bit more interesting than just calling <code>ToString()</code> on the object, because it attempts to capture the actual structure of the object. For example:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; var x = new List&lt;string&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; x.Add(&quot;foo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;string&gt;(1) { &quot;foo&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; x.Add(&quot;bar&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; x</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;string&gt;(2) { &quot;foo&quot;, &quot;bar&quot; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="inline-nuget-packages">Inline Nuget packages<a class="hash-link" href="#inline-nuget-packages" title="Direct link to heading">​</a></h3><p>REPL also supports inline Nuget packages - meaning the Nuget packages can be installed into the REPL from <em>within the REPL</em>. This is done via our <code>#r</code> and <code>#load</code> from Nuget support and uses identical syntax.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; #r &quot;nuget: Automapper, 6.1.1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; using AutoMapper;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; typeof(MapperConfiguration)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[AutoMapper.MapperConfiguration]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; #load &quot;nuget: simple-targets-csx, 6.0.0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; using static SimpleTargets;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; typeof(TargetDictionary)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[Submission#0+SimpleTargets+TargetDictionary]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="multiline-mode">Multiline mode<a class="hash-link" href="#multiline-mode" title="Direct link to heading">​</a></h3><p>Using Roslyn syntax parsing, we also support multiline REPL mode. This means that if you have an uncompleted code block and press <kbd>Enter</kbd>, we will automatically enter the multiline mode. The mode is indicated by the <code>*</code> character. This is particularly useful for declaring classes and other more complex constructs.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; class Foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* public string Bar {get; set;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; var foo = new Foo();</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="repl-commands">REPL commands<a class="hash-link" href="#repl-commands" title="Direct link to heading">​</a></h3><p>Aside from the regular C# script code, you can invoke the following commands (directives) from within the REPL:</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#load</code></td><td>Load a script into the REPL (same as <code>#load</code> usage in CSX)</td></tr><tr><td><code>#r</code></td><td>Load an assembly into the REPL (same as <code>#r</code> usage in CSX)</td></tr><tr><td><code>#reset</code></td><td>Reset the REPL back to initial state (without restarting it)</td></tr><tr><td><code>#cls</code></td><td>Clear the console screen without resetting the REPL state</td></tr><tr><td><code>#exit</code></td><td>Exits the REPL</td></tr></tbody></table><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="seeding-repl-with-a-script">Seeding REPL with a script<a class="hash-link" href="#seeding-repl-with-a-script" title="Direct link to heading">​</a></h3><p>You can execute a CSX script and, at the end of it, drop yourself into the context of the REPL. This way, the REPL becomes &quot;seeded&quot; with your code - all the classes, methods or variables are available in the REPL context. This is achieved by running a script with an <code>-i</code> flag.</p><p>For example, given the following CSX script:</p><div class="codeBlockContainer_I0IT language-csharp theme-code-block"><div class="codeBlockContent_wNvx csharp"><pre tabindex="0" class="prism-code language-csharp codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">var msg = &quot;Hello World&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Console.WriteLine(msg);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>When you run this with the <code>-i</code> flag, <code>Hello World</code> is printed, REPL starts and <code>msg</code> variable is available in the REPL context.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script foo.csx -i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>You can also seed the REPL from inside the REPL - at any point - by invoking a <code>#load</code> directive pointed at a specific file. For example:</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">~$ dotnet script</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt; #load &quot;foo.csx&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hello World</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="管道">管道<a class="hash-link" href="#管道" title="Direct link to heading">​</a></h2><p>下面的例子演示了如何在脚本中使用输入/输出的管道数据.</p><p><code>UpperCase.csx</code> 脚本简单地把标准输入转换成大写后写入到标准输出中.</p><div class="codeBlockContainer_I0IT language-csharp theme-code-block"><div class="codeBlockContent_wNvx csharp"><pre tabindex="0" class="prism-code language-csharp codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#! &quot;netcoreapp2.1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using (var streamReader = new StreamReader(Console.OpenStandardInput()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Write(streamReader.ReadToEnd().ToUpper());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>我们现在简单地把一个命令的输出转入到我们的脚本中:</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">echo</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;This is some text&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> dotnet script UpperCase.csx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">THIS IS SOME TEXT</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h3 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="调试-1">调试<a class="hash-link" href="#调试-1" title="Direct link to heading">​</a></h3><p>The first thing we need to do add the following to the <code>launch.config</code> file that allows VS Code to debug a running process.</p><div class="codeBlockContainer_I0IT language-JSON theme-code-block"><div class="codeBlockContent_wNvx JSON"><pre tabindex="0" class="prism-code language-JSON codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;name&quot;: &quot;.NET Core Attach&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;type&quot;: &quot;coreclr&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;request&quot;: &quot;attach&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;processId&quot;: &quot;${command:pickProcess}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To debug this script we need a way to attach the debugger in VS Code and to the simplest thing we can do here is to wait for the debugger to attach by adding this method somewhere.</p><div class="codeBlockContainer_I0IT language-c# theme-code-block"><div class="codeBlockContent_wNvx c#"><pre tabindex="0" class="prism-code language-c# codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">public static void WaitForDebugger()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Console.WriteLine(&quot;Attach Debugger (VS Code)&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(!Debugger.IsAttached)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To debug the script when executing it from the command line we can do something like</p><div class="codeBlockContainer_I0IT language-c# theme-code-block"><div class="codeBlockContent_wNvx c#"><pre tabindex="0" class="prism-code language-c# codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">#! &quot;netcoreapp2.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#r &quot;nuget: NetStandard.Library, 2.0.0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WaitForDebugger();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using (var streamReader = new StreamReader(Console.OpenStandardInput()))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Write(streamReader.ReadToEnd().ToUpper()); // &lt;- SET BREAKPOINT HERE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Now when we run the script from the command line we will get</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">$ </span><span class="token builtin class-name">echo</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;This is some text&quot;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">|</span><span class="token plain"> dotnet script UpperCase.csx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Attach Debugger </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">VS Code</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This now gives us a chance to attach the debugger before stepping into the script and from VS Code, select the  <code>.NET Core Attach</code> debugger and pick the process that represents the executing script.</p><p>Once that is done we should see out breakpoint being hit.</p><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="configurationdebugrelease">Configuration(Debug/Release)<a class="hash-link" href="#configurationdebugrelease" title="Direct link to heading">​</a></h2><p>By default, scripts will be compiled using the <code>debug</code> configuration. This is to ensure that we can debug a script in VS Code as well as attaching a debugger for long running scripts.</p><p>There are however situations where we might need to execute a script that is compiled with the <code>release</code> configuration. For instance, running benchmarks using <a href="http://benchmarkdotnet.org/" target="_blank" rel="noopener noreferrer">BenchmarkDotNet</a> is not possible unless the script is compiled with the <code>release</code> configuration.</p><p>We can specify this when executing the script.</p><div class="codeBlockContainer_I0IT language-shell theme-code-block"><div class="codeBlockContent_wNvx shell"><pre tabindex="0" class="prism-code language-shell codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">dotnet script foo.csx -c release</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="team">Team<a class="hash-link" href="#team" title="Direct link to heading">​</a></h2><ul><li><a href="https://github.com/seesharper" target="_blank" rel="noopener noreferrer">Bernhard Richter</a> (<a href="https://twitter.com/bernhardrichter" target="_blank" rel="noopener noreferrer">@bernhardrichter</a>)</li><li><a href="https://github.com/filipw" target="_blank" rel="noopener noreferrer">Filip W</a> (<a href="https://twitter.com/filip_woj" target="_blank" rel="noopener noreferrer">@filip_woj</a>)</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_R0VQ" id="license">License<a class="hash-link" href="#license" title="Direct link to heading">​</a></h2><p><a href="https://github.com/filipw/dotnet-script/blob/master/LICENSE" target="_blank" rel="noopener noreferrer">MIT License</a></p></div><footer class="row blogPostDetailsFull_enUA docusaurus-mt-lg"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/net/">.net</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/blog/tags/net-core/">.net core</a></li></ul></div></footer><div id="gitalk-container"></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/blog/2022/03/24/flutter-qa/"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Flutter QA</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/blog/2022/03/16/dotnet-starter/"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">.Net Core QA</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li><li><a href="#安装" class="table-of-contents__link toc-highlight">安装</a><ul><li><a href="#要求" class="table-of-contents__link toc-highlight">要求</a></li><li><a href="#net-core-21-global-tool" class="table-of-contents__link toc-highlight">.Net Core 2.1 Global Tool</a></li><li><a href="#windows" class="table-of-contents__link toc-highlight">Windows</a></li><li><a href="#linux-and-mac" class="table-of-contents__link toc-highlight">Linux and Mac</a></li><li><a href="#docker" class="table-of-contents__link toc-highlight">Docker</a></li><li><a href="#github" class="table-of-contents__link toc-highlight">Github</a></li></ul></li><li><a href="#usage" class="table-of-contents__link toc-highlight">Usage</a><ul><li><a href="#脚手架" class="table-of-contents__link toc-highlight">脚手架</a></li><li><a href="#运行脚本" class="table-of-contents__link toc-highlight">运行脚本</a><ul><li><a href="#向脚本中传递参数" class="table-of-contents__link toc-highlight">向脚本中传递参数</a></li></ul></li><li><a href="#nuget-包" class="table-of-contents__link toc-highlight">NuGet 包</a><ul><li><a href="#nuget包源" class="table-of-contents__link toc-highlight">Nuget包源</a></li></ul></li><li><a href="#从csx文件创建dll或者可执行文件" class="table-of-contents__link toc-highlight">从CSX文件创建DLL或者可执行文件</a></li><li><a href="#缓存" class="table-of-contents__link toc-highlight">缓存</a><ul><li><a href="#依赖缓存-dependency-cache" class="table-of-contents__link toc-highlight">依赖缓存 Dependency Cache</a></li><li><a href="#execution-cache" class="table-of-contents__link toc-highlight">Execution cache</a></li></ul></li><li><a href="#调试" class="table-of-contents__link toc-highlight">调试</a></li><li><a href="#脚本包-script-packages" class="table-of-contents__link toc-highlight">脚本包 Script Packages</a><ul><li><a href="#创建脚本包" class="table-of-contents__link toc-highlight">创建脚本包</a></li><li><a href="#消费脚本包" class="table-of-contents__link toc-highlight">消费脚本包</a></li></ul></li><li><a href="#远程脚本" class="table-of-contents__link toc-highlight">远程脚本</a></li><li><a href="#script-location" class="table-of-contents__link toc-highlight">Script Location</a></li></ul></li><li><a href="#repl" class="table-of-contents__link toc-highlight">REPL</a><ul><li><a href="#基本使用" class="table-of-contents__link toc-highlight">基本使用</a></li><li><a href="#inline-nuget-packages" class="table-of-contents__link toc-highlight">Inline Nuget packages</a></li><li><a href="#multiline-mode" class="table-of-contents__link toc-highlight">Multiline mode</a></li><li><a href="#repl-commands" class="table-of-contents__link toc-highlight">REPL commands</a></li><li><a href="#seeding-repl-with-a-script" class="table-of-contents__link toc-highlight">Seeding REPL with a script</a></li></ul></li><li><a href="#管道" class="table-of-contents__link toc-highlight">管道</a><ul><li><a href="#调试-1" class="table-of-contents__link toc-highlight">调试</a></li></ul></li><li><a href="#configurationdebugrelease" class="table-of-contents__link toc-highlight">Configuration(Debug/Release)</a></li><li><a href="#team" class="table-of-contents__link toc-highlight">Team</a></li><li><a href="#license" class="table-of-contents__link toc-highlight">License</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">文章列表</h4><ul class="footer__items"><li class="footer__item"> <a class="footer__link-item" href="/docs/articles/es6-in-depth/introduction/">深入浅出ES6 - InfoQ.cn</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/articles/why-java-sucks-and-csharp-rocks/compare-purpose/">Why Java Sucks and C# Rocks - 赵劼</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/reading/">阅读笔记</a> </li><li class="footer__item"> <a class="footer__link-item" href="/docs/archives/git-guides/">博文归档</a> </li></ul></div><div class="col footer__col"><h4 class="footer__title">文档翻译</h4><ul class="footer__items"><li class="footer__item"> <a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="/blog/2022/03/16/dotnet-script-intro/docs/guides/blog/">Docusaurus Blog</a> </li><li class="footer__item"> <a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="/blog/2022/03/16/dotnet-script-intro/docs/guides/docs/markdown-features/">Docusaurus Markdown</a> </li><li class="footer__item"> <a class="footer__link-item" target="_blank" rel="noopener noreferrer" href="/blog/2022/03/12/caddy-intro/">Caddy 简介</a> </li></ul></div><div class="col footer__col"><h4 class="footer__title">更多</h4><ul class="footer__items"><li class="footer__item"> <a href="https://github.com/alanwei43/node-io-lib" target="_blank" rel="noopener noreferrer" class="footer__link-item">node-io-lib - GitHub</a> </li><li class="footer__item"> <a href="https://github.com/alanwei43/docker-puppeteer" target="_blank" rel="noopener noreferrer" class="footer__link-item">docker-puppeteer - GitHub</a> </li><li class="footer__item"> <a href="https://github.com/alanwei43/code-server" target="_blank" rel="noopener noreferrer" class="footer__link-item">code-server - GitHub</a> </li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Alan&#x27;s Blog<!-- --> <a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer"> </a></div></div></div></footer></div>
<script src="/assets/js/runtime~main.73df28f9.js"></script>
<script src="/assets/js/main.25a66b22.js"></script>
</body>
</html>