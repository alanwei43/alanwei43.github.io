<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">async/await异步模型是否优于stackful coroutine模型？  -  Alan&#x27;s Blog</title><meta data-rh="true" name="baidu-site-verification" content="code-7RGpEH8jty"><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://blog.alanwei.com/blog/2022/07/12/why-async-await-better-stackful-coroutine"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="async/await异步模型是否优于stackful coroutine模型？  -  Alan&#x27;s Blog"><meta data-rh="true" name="description" content="这里说的coroutine是stackful的，可以对比js的async/await和fibjs，还有c#的async/await对比go的goroutine。 async/await的优点是不需要为每个coroutine分配单独的栈内存，只需要一个闭包保存状态，避免了内存浪费；在调度上也更加灵活，可以让用户手动调度；另外在实现上也不需要改动虚拟机，只要在语言层面加上generator的支持就可以实现。那么是不是可以认为async/await是一个更好的异步方案呢？"><meta data-rh="true" property="og:description" content="这里说的coroutine是stackful的，可以对比js的async/await和fibjs，还有c#的async/await对比go的goroutine。 async/await的优点是不需要为每个coroutine分配单独的栈内存，只需要一个闭包保存状态，避免了内存浪费；在调度上也更加灵活，可以让用户手动调度；另外在实现上也不需要改动虚拟机，只要在语言层面加上generator的支持就可以实现。那么是不是可以认为async/await是一个更好的异步方案呢？"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-07-12T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="知乎,JavaScript"><link data-rh="true" rel="icon" href="/img/favicon.png"><link data-rh="true" rel="canonical" href="https://blog.alanwei.com/blog/2022/07/12/why-async-await-better-stackful-coroutine"><link data-rh="true" rel="alternate" href="https://blog.alanwei.com/blog/2022/07/12/why-async-await-better-stackful-coroutine" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.alanwei.com/blog/2022/07/12/why-async-await-better-stackful-coroutine" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://7SQ6A6EP36-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Alan&#39;s Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Alan&#39;s Blog Atom Feed">



<link rel="search" type="application/opensearchdescription+xml" title="Alan&#39;s Blog" href="/opensearch.xml">





<link rel="stylesheet" href="/styles/global.css">
<script src="/scripts/baidu.js"></script>
<script src="/scripts/bing-clarity.js"></script>
<script src="/scripts/google.js"></script><link rel="stylesheet" href="/assets/css/styles.46ae3731.css">
<link rel="preload" href="/assets/js/runtime~main.fac87c37.js" as="script">
<link rel="preload" href="/assets/js/main.8f5aa10d.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top navbarHideable_m1mJ"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.png" alt="logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Alan&#x27;s Blog</b></a><a class="navbar__item navbar__link" href="/docs/articles">Articles</a><a class="navbar__item navbar__link" href="/docs/reading">Reading</a><a class="navbar__item navbar__link" href="/docs/built-in">Documents</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/me">Abount me</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/alanwei43" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_brwN thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_r4Q1 margin-bottom--md">Top posts</div><ul class="sidebarItemList_QwSx clean-list"><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2022/03/12/caddy-intro/">Caddy 简介</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2022/11/27/fnm-node-version-manager">fnm - Node版本管理工具</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2022/07/21/graphql-intro">GraphQL intro</a></li></ul><div class="sidebarItemTitle_r4Q1 margin-bottom--md">Recent posts</div><ul class="sidebarItemList_QwSx clean-list"><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2024/01/06/third-party-cookie">Thrid-Party Cookie</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/12/27/ubuntu-logout">Ubuntu 退出登录</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/11/node-sass-install-fail">解决 node-sass 依赖安装失败问题</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/09/18/webm-to-mp4">webm转换mp4</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/08/06/vscode-previous-release-versions-download">VSCode 历史版本下载</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/07/28/chrome-touchevent-passive">Chrome TouchEvent passive 参数介绍</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/06/23/macos-wechat-backup-location">macOS 系统微信聊天记录备份目录</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/06/14/linux-port-forward-socat">Linux系统端口转发</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/06/12/javascript-shuffle">JavaScript 乱序(洗牌)算法</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/05/28/ubuntu-chinese-input-method">Ubuntu 安装中文输入法</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/05/11/vim-json">Vim format JSON</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/05/04/dingtalk-update">钉钉 Ubuntu/Debian 下载地址</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/05/03/docker-offline-install">Downloading docker image for transfer to non-internet-connected machine</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/04/30/rsync-with-custom-port">rsync 同步文件指定端口号</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/04/30/vmware-install-android">使用 VMware 安装 Android</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/04/15/gradle-development">Gradle 开发配置</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/03/27/nginx-location-directive">NGINX location 指令示例</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/03/17/gnome-shell">Ubuntu install gnome</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/03/09/vue-cli-es5">Vue2项目构建没有转换ES6语法</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/03/07/nuxt-insert-inline-script">Nuxt 插入内联脚本</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/21/chrome-redirect-https-from-http">解决 Chrome 记住 HTTP 自动跳转 HTTPS</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/12/docusaurus-multi-documents">Docusaurus 多个文档</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/10/linux-skills">Linux 技巧</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/08/ubuntu-permanently-remove-sidebar-video">删除 Files 侧边栏预置目录</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/05/amazon-kindle-backup">Amazon Kindle 电子书备份</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/02/04/linux-chrome-disable-password">Ubuntu启动Chrome去掉每次输入密码</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/01/09/awesome-code-snippet">Awesome Code Snippet</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2023/01/08/live-stream-server">Live Stream Server</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2022/12/29/pm2-config">PM2 配置文件介绍</a></li><li class="sidebarItem_lnhn"><a class="sidebarItemLink_yNGZ" href="/blog/2022/12/26/flutter-develop-environment-setup">Flutter 开发环境设置</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">async/await异步模型是否优于stackful coroutine模型？</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-07-12T00:00:00.000Z" itemprop="datePublished">July 12, 2022</time> · <!-- -->18 min read</div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="问题">问题<a href="#问题" class="hash-link" aria-label="Direct link to 问题" title="Direct link to 问题">​</a></h2><p><strong>async/await异步模型是否优于stackful coroutine模型？</strong></p><p>这里说的coroutine是stackful的，可以对比js的async/await和fibjs，还有c#的async/await对比go的goroutine。</p><p>async/await的优点是不需要为每个coroutine分配单独的栈内存，只需要一个闭包保存状态，避免了内存浪费；在调度上也更加灵活，可以让用户手动调度；另外在实现上也不需要改动虚拟机，只要在语言层面加上generator的支持就可以实现。那么是不是可以认为async/await是一个更好的异步方案呢？</p><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="回答">回答<a href="#回答" class="hash-link" aria-label="Direct link to 回答" title="Direct link to 回答">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="乔捷">乔捷<a href="#乔捷" class="hash-link" aria-label="Direct link to 乔捷" title="Direct link to 乔捷">​</a></h3><blockquote><p>原文 <a href="https://www.zhihu.com/question/65647171/answer/233781797" target="_blank" rel="noopener noreferrer">乔捷</a>
自答一波，好多答案里似乎都搞错了概念，导致了一些无谓的争议。这里谈一下我的理解。</p></blockquote><p>首先coroutine
是个很宽泛的概念，async/await</p><p>也属于coroutine的一种。但是问题是拿async/await和stackful coroutine比较。所谓stackful是指每个coroutine有独立的运行栈，比如每个goroutine会分配一个4k的内存来做为运行栈，切换goroutine的时候运行栈也会切换。stackful的好处在于这种coroutine是完整的，coroutine可以嵌套、循环。</p><p>与stackful对应的是stackless coroutine，比如generator,continuation
，这类coroutine不需要分配单独的栈空间，coroutine状态保存在闭包里，但缺点是功能比较弱，不能被嵌套调用，也没办法和异步函数</p><p>配合使用进行控制流的调度，所以基本上没办法跟stackful coroutine做比较。</p><p>但是async/await的出现，实现了基于stackless coroutine的完整coroutine。在特性上已经非常接近stackful coroutine了，不但可以嵌套使用也可以支持try catch。所以是不是可以认为async/await是一个更好的方案？</p><p>最后有个匿名用户死活在哪里纠结并发需要多线程，这里我统一做个回复。很多人是从多核时代入行的，看到的异步框架都是使用了线程池，所以想当然的认为并发必须依赖多线程去处理，更有人连并发和并行的概念都搞混，认为单核CPU就不能并发了。实际上并发这个概念在没有多核CPU甚至没有线程的年代（早期的Linux是没有线程的）就有了。并发一般特指IO，IO是独立于CPU的设备，IO设备通常远远慢于CPU，所以我们引入了并发的概念，让CPU可以一次性发起多个IO操作而不用等待IO设备做完一个操作再做令一个。怎么实现呢？原理就是非阻塞操作+事件通知，在核心态非阻塞操作对应的是读写端口和DMA，而事件通知则有专门的术语叫中断响应。过程有2种，一种是IO设备发起中断告诉CPU现在可以进行IO操作，然后CPU进行相应的操作，还有一种是CPU先发起IO操作，然后IO设备完成处理后发起中断告诉CPU操作完成。在核心态是不存在多线程这种概念的，一切都是异步的事件驱动（中断响应），线程是核心给用户态提供的高层概念，线程本身也依赖中断来进行调度。早期的用户态IO并发处理是用poll(select)模型去轮询IO状态，然后发起相应的IO操作，称之为事件响应式的异步模型，这种方式并不容易使用，所以又发展出了阻塞式IO操作，让逻辑挂起并等待IO完成，为了让阻塞式IO能够并发就必须依赖多线程或者多进程模型来实现。但是线程的开销是非常大的，当遇到大规模并发的时候多线程模型就无法胜任了。所以大规模并发时我们又退回去使用事件响应，epoll在本质上还是poll模型，只是在算法上优化了实现，此时我们只用单线程就可以处理上万的并发请求了。直到多核CPU的出现，我们发现只用一个线程是无法发挥多核CPU的威力的，所以再次引入线程池来分摊IO操作的CPU消耗，甚至CPU的中断响应也可以由多个核来分摊执行，此时的线程数量是大致等于CPU的核心数而远小于并发IO数的（这时CPU能处理百万级的并发），线程的引入完全是为了负载均衡而跟并发没有关系。所以不管是用select/epoll/iocp在逻辑层都绕不开基于事件响应的异步操作，面对异步逻辑本身的复杂性，我们才引入了async/await以及coroutine来降低复杂性。</p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="朱元">朱元<a href="#朱元" class="hash-link" aria-label="Direct link to 朱元" title="Direct link to 朱元">​</a></h3><blockquote><p>原文 <a href="https://www.zhihu.com/question/65647171/answer/233495694" target="_blank" rel="noopener noreferrer">朱元</a></p></blockquote><p>我们要先想清楚:问题是什么？</p><p>当代码遇到一个“暂时不能完成”的流程时（例如建立一个tcp链接，可能需要5ms才能建立），他不想阻塞在这里睡眠，想暂时离开现场yield</p><p>去干点别的事情（例如看看另外一个已经建立的链接是否可以收包了）。问题是：离开现场后，当你回来的时候，上下文还像你走的时候吗？</p><p>跳转离开，在任何语言里都有2种最基本的方法：1）从当前函数返回； 2）调用一个新的函数。 前者会把上下文中的局部变量和函数参数全部摧毁，除非他返回前把这些变量找个别的地方保存起来；后者则能保护住整个上下文的内存（除了函数返回之后会摧毁一些我们高级语言所看不见的寄存器），而且跳转回来也是常规方法：函数返回。</p><p>async/await和有栈协程的区别就在于，在这里分别选用了这2种方法：</p><p>前者（async/await）在函数返回前把那些变量临时保存在堆的某个地方，然后把存放地址传回去，当你想返回现场的时候，把这些变量恢复，并跳转回离开时候那个语句；持有指针语义的c/c++语言则略麻烦：因为可能这些局部变量中有谁持有另一个局部变量的地址，这样“值语义”的恢复就会把他们变成野指针，所以需要在进入函数时所有的局部变量和函数参数都在堆上分配，这样就不会有谁持有离开时栈上下文的指针了，换句话说，对c/c++来说，这是一种无栈协程(有些自己写的无栈协程库提供你在堆上面分配局部变量的接口，或者强迫你在进入这个函数前把要用到的所有局部变量在堆上面分配好内存)，其它语言只要没有值语义或变量天生不放栈上就没这个概念。如果使用闭包语法返回现场，可以只需要恢复闭包中捕获的变量；对于c++，在离开现场时不能提前析构掉那些没有被捕获的变量（否则析构顺序未必是构造顺序的反序，其实这个c++规则真是没必要）。所以从C++的观点来说，这是一种彻头彻尾的“假”函数返回(有垃圾回收器的语言倒是有可能走到async之后的语句后，回收前面已经不用的临时变量)。</p><p>后者（有栈协程）在离开前只需要把函数调用中可能被破坏的callee-saved 寄存器给保存在当前栈就完事了（别的协程和当前协程栈是完全隔离的，不会破坏自己堆栈），跳转回来的时候把在栈中保存的寄存器</p><p>都恢复了并跳转回离开时候那个语句就行了。</p><p>综上：前者（尤其是c、c++）需要编译器的特殊支持，对使用了async/await语义的函数中的局部变量的分配，恢复进行些特殊的处理；后者则只需要写写汇编就搞定了（一般需要给 进入协程入口函数，协程间切换，协程函数入口函数返回后回收协程资源并切换去另一个协程 这3个地方写点汇编，也有的协程库把这3种情况都统一起来处理）。</p><p>谁优谁劣呢？</p><p>语法友好度：衡量这个玩意儿的标准，莫过于“逻辑聚合性”：逻辑相关的代码能否写在相近的代码处。例如 redis/nginx中处处可见这种上下文被分割的代码，因为任何一个“暂时不能完成“的场景都会把场景前后代码逻辑写在完全不同的两个函数里。。对于async/await 或无栈协程语义，c/c++在没有闭包之前的，还需要达夫设备跳转回离开现场的那行代码，有了闭包之后，上下文之间就只被<code>return ( [xxx](){</code> 分开了，代码可以认为基本没有被分割( C# 新版js, VC和clang实验性的resumable function连这点分开都没有了)；不过依然远远比不上有栈协程，因为他语法完全是常规的函数调用/函数返回，使用hook之类的手法甚至可以把已有的阻塞代码自动yield加无阻塞化（参见libco, libgo）。可以认为在这一项：前者在得到现代化编译器辅助后，和后者相近但依然有差距且容易对一些常识产生挑战；后者语法非常适合传统编程逻辑。</p><p>时间/空间效率：async/await 语义执行的是传统的函数调用函数返回流程，没有对栈指针进行手工修改操作，cpu对return stack buffer的跳转预测优化继续有效；有栈协程需要在创建时根据协程代码执行的最坏情况提前分配好协程函数的栈，这往往都分配的过大而缺乏空间效率，而且在协程间切换的时候手工切换栈，从而破坏了return stack buffer跳转预测，协程切换后函数的每一次返回都意味着一次跳转预测失效，所以流程越复杂有栈协程的切换开销越大（非对称调度的有栈协程会降低一些这方面的开销，boost新版有栈协程彻底抛弃了对称协程）。对于async/await 语义实践的无栈协程，如果允许提前析构不被捕获的C++变量，或者你返回前手工销毁或者你用的是带垃圾回收器的语言，空间效率会更佳。 可以认为在这一项：前者远胜后者，而且后者会随着你业务复杂度加深以及cpu流水线的变长（还好奔4过后的架构不怎么涨了）而不断变差。笔者写的yuanzhubi/call_in_stack yuanzhubi/local_hook， 以及一个没有开源的jump assembler（把有栈协程切换后的代码输出的汇编语句中的ret指令全部换成pop+jmp指令再编译，避开return stack buffer 预测失败）都是来优化有栈协程在时间/空间的表现的 。</p><p>调度：其实2者都是允许用户自己去管理调度事宜的，不过前者必须返回由调度函数选择下一个无栈协程的切入，后者允许”深度优先调度“：即当某个协程发现有“暂时不能完成“的场景时自己可以根据当前场景选择一个逻辑相关的协程进行切入，提升内存访问局部性，不过这对使用者的要求和业务侵入度非常高。。整体而言的话，可以认为在这一项：前者和后者大致持平，前者是集中式管理而后者是分布式管理</p><p>，后者可以挖掘的潜力更高但对使用者要求很高且未必能适应业务的变更。</p><p>结论：性能上，前者有一定时间优势但不是精雕细琢的多用途公共开源组件完全可以忽略，而空间上前者超越后者很多；易用度上，前者正在快速演进 慢慢的追上后者（c#这样的async/await鼻祖已经完全不存在这个问题）；和已有组件的可结合度上，后者始终保持优势（不管已有组件是源码还是二进制）。孰优孰劣，如何侧重，如何选择（如果你们有选择的机会的话），，也许 纯属你头儿的口味问题吧 哈哈哈。</p><p>看到很多同学提状态机，其实这种理解没有什么问题，而是人和编译器的观点有所不同：人会抽象出很多状态，在痛苦这些状态如何在各种上下文跳转中传递和保存（状态机）; 编译器则在痛苦怪异的上下文跳转中，局部变量的保存和恢复(无栈协程)。 前者会自行决定某些局部变量是“真的局部”变量，后续无需恢复了；后者会把他们全盘考虑下来，把所有的量都要在各个状态间传递和保存（当然有的语言可以智能些，按需传递）。从本质来说，如果是由编译器来玩状态机实现的async/await和无栈协程的，概念上没有什么区别。 人才说状态，机器只说变量，内存这些。</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/知乎">知乎</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/java-script">JavaScript</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/alanwei43/blog/tree/master/src/blog/2022/07/12-why-async-await-better-stackful-coroutine.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/2022/07/12/pass-all-props-to-children"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Pass all props to children in Vue</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/2022/06/17/typescript-ignore-rules"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">TypeScript禁用规则</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#问题" class="table-of-contents__link toc-highlight">问题</a></li><li><a href="#回答" class="table-of-contents__link toc-highlight">回答</a><ul><li><a href="#乔捷" class="table-of-contents__link toc-highlight">乔捷</a></li><li><a href="#朱元" class="table-of-contents__link toc-highlight">朱元</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Recommend</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/articles/es6-in-depth/introduction">深入浅出ES6 - InfoQ.cn</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/articles/why-java-sucks-and-csharp-rocks/compare-purpose">Why Java Sucks and C# Rocks - 赵劼</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/reading">阅读笔记</a></li></ul></div><div class="col footer__col"><div class="footer__title">Translate</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/built-in/docusaurus/">Docusaurus Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/built-in/docusaurus/docs/markdown-features">Docusaurus Markdown</a></li><li class="footer__item"><a class="footer__link-item" href="/blog/2022/03/12/caddy-intro">Caddy 简介</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/alanwei43/node-io-lib" target="_blank" rel="noopener noreferrer" class="footer__link-item">node-io-lib - GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/alanwei43/docker-puppeteer" target="_blank" rel="noopener noreferrer" class="footer__link-item">docker-puppeteer - GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/alanwei43/code-server" target="_blank" rel="noopener noreferrer" class="footer__link-item">code-server - GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 Alan's Blog</div></div></div></footer></div>
<script src="/assets/js/runtime~main.fac87c37.js"></script>
<script src="/assets/js/main.8f5aa10d.js"></script>
</body>
</html>